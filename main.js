import './style.scss'
import 'mobile-drag-drop/default.css'
import FlMMLWorkerLocation from './flmml-on-html5.worker.js?url'

import {FlMML} from 'flmml-on-html5';
import localForage from 'localforage';
import {Picker} from 'emoji-picker-element';
import {polyfill} from 'mobile-drag-drop';
import {htmlspecialchars, resetAnimation, useVisualViewportToCss} from './utils';

const version = import.meta.env.VITE_APP_VER;

document.addEventListener('DOMContentLoaded', () => {
    const mmlForm = document.forms['mml-line'];
    mmlForm.add = {
        field: mmlForm.elements['add-mml'],
        mmlText: mmlForm.elements['add-mml-text'],
        btn: mmlForm.elements['add-button']
    };
    mmlForm.del = {
        field: mmlForm.elements['delete-mml'],
        index: mmlForm.elements['delete-mml-index'],
        btn: mmlForm.elements['delete-button']
    }
    mmlForm.rw = {
        field: mmlForm.elements['rewrite-mml'],
        index: mmlForm.elements['rewrite-mml-index'],
        mmlText: mmlForm.elements['rewrite-mml-text'],
        btn: mmlForm.elements['rewrite-button']
    }
    const editor = document.querySelector('.editor');
    const tones = document.getElementById('tones');
    const action = document.getElementById('action');
    const musicalScore = document.getElementById('musical-score');
    const dialog = document.getElementById('dialog');
    const dialogForm = document.forms['dialog-form'];
    dialogForm._title = dialogForm.querySelector('.form-title');
    dialogForm.inputs = dialogForm.querySelector('.inputs');
    dialogForm.buttons = dialogForm.querySelector('.buttons');
    const playBtn = document.getElementById('play');
    const clearBtn = document.getElementById('clear');
    const warnOut = document.getElementById('warn-out');
    const mmlOut = document.getElementById('mml');
    const copyBtn = document.getElementById('copy');
    const saveBtn = document.getElementById('save');
    const openBtn = document.getElementById('open');
    const ctrlBtn = document.getElementById('ctrl');

    class Mml {
        #generatorComment = `#COMMENT Generated by FlMML VisualSequencer ${version}`;
        #mml = [];
        #changeHandler = (arr, mmlText) => {};
        #errorHandler = (error, reason) => {};

        set onChange(fn) {
            this.#changeHandler = fn;
        }

        set onError(fn) {
            this.#errorHandler = fn;
        }

        setMmlArr(arr) {
            this.#mml = arr;
            this.#changeHandler(this.getMmlArr(), this.getMml());
        }

        setMml(str) {
            this.#mml = str.split('\n');
            const isGeneratedMmlText = this.#mml.at(-2) === '' && this.#mml.at(-1) === this.#generatorComment;
            if (isGeneratedMmlText) {
                this.#mml.splice(-2, 2);
            }
            this.#changeHandler(this.getMmlArr(), this.getMml());
        }

        getMmlArr() {
            return this.#mml;
        }

        getMml() {
            if (this.#mml.length) {
                return this.#mml.concat([
                    '',
                    this.#generatorComment
                ]).join('\n');
            } else {
                return '';
            }
        }

        getMmlLine(i) {
            return this.#mml[i];
        }

        insert(i, str) {
            const valid = Object.hasOwn(this.#mml, i) || i === 0;
            if (valid) {
                this.#mml.splice(i, 0, str);
                this.#changeHandler(this.getMmlArr(), this.getMml());
            } else {
                this.#errorHandler('範囲外の書き換え指定', `範囲${this.#mml.length - 1}までのところ、${i}`);
            }
        }

        append(str) {
            this.#mml.push(str);
            this.#changeHandler(this.getMmlArr(), this.getMml());
        }

        appendToStr(i, str) {
            const valid = Object.hasOwn(this.#mml, i);
            if (valid) {
                this.#mml[i] += str;
                this.#changeHandler(this.getMmlArr(), this.getMml());
            } else {
                this.append(str);
            }
        }

        beforeInsertToStr(i, str) {
            const valid = Object.hasOwn(this.#mml, i);
            if (valid) {
                this.#mml[i] = str + this.#mml[i];
                this.#changeHandler(this.getMmlArr(), this.getMml());
            } else {
                this.append(str);
            }
        }

        rewrite(i, str) {
            const valid = Object.hasOwn(this.#mml, i);
            if (valid) {
                this.#mml[i] = str;
                this.#changeHandler(this.getMmlArr(), this.getMml());
            } else {
                this.append(str);
            }
        }

        delete(i, delCount = 1) {
            const valid = Object.hasOwn(this.#mml, i);
            if (valid && this.#mml.splice(i, delCount).length !== 0) {
                this.#changeHandler(this.getMmlArr(), this.getMml());
            } else {
                this.#errorHandler('無効な指定', `範囲${this.#mml.length - 1}までの中で${i}から${delCount}削除するのはできません`);
            }
        }
    }

    class Block {
        #blocksData = [];
        #rendTimeout = null;
        #saveDelayTimer = null;

        constructor(tones, areaElem) {
            this.tonesElem = tones;
            this.areaElem = areaElem;
        }

        blocksDataUpdate() {
            this.#blocksData = [...this.areaElem.getElementsByTagName('button')].map(elem => ({
                label: elem.ariaLabel,
                className: elem.className,
                tone: {
                    tone: elem.dataset.tone,
                    tonePitch: elem.dataset.tonePitch
                },
                tempo: elem.dataset.tempo,
                noteValue: elem.dataset.noteValue,
                rest: elem.dataset.rest,
                octave: elem.dataset.octave,
                velocity: elem.dataset.velocity,
                noteShift: elem.dataset.noteShift,
                detune: elem.dataset.detune,
                loopStart: elem.dataset.loopStart,
                loopBreak: elem.dataset.loopBreak,
                loopEnd: elem.dataset.loopEnd,
                usingPoly: elem.dataset.usingPoly,
                polyStartEnd: elem.dataset.polyStartEnd,
                otherAction: elem.dataset.otherAction,
                elem: elem
            }));
        }

        saveBlocksData() {
            clearTimeout(this.#saveDelayTimer);
            this.#saveDelayTimer = setTimeout(() => {
                const modifiedData = JSON.parse(JSON.stringify(this.#blocksData));
                localForage.setItem('BlocksData', modifiedData)/* .then(() => console.log('saved')) */.catch(err => {
                    alert('セーブができませんでした。' + err);
                });
            }, 1000);
        }

        checkSavedBlocksData() {
            localForage.getItem('BlocksData').then(data => {
                if (data) {
                    this.#blocksData = data;
                    this.parseBlocks();
                    this.blocksDataUpdate();
                    this.calcPoly();
                    this.exportMml(mml);
                }
            });
        }

        parseBlocks() {
            const data = this.#blocksData;
            // console.log(data);
            const ul = this.areaElem.querySelector('ul');
            const tonesUl  = this.tonesElem.querySelector('ul');
            let noteCount = 1;
            data.forEach(block => {
                const li = document.createElement('li');
                const toneButtonHTML = `<button class="material-icons note note-${noteCount}" aria-label="無調整" draggable="true" data-tone="" data-tone-pitch="c">music_note</button>`;
                const toneButton = (() => {
                    const wrap = document.createElement('div');
                    wrap.innerHTML = toneButtonHTML;
                    return wrap.firstElementChild;
                })();
                const copySourceCandidate = document.querySelector(`[class*="${block.className.replace(/ droppable| bounce| pop| done/g, '')}"]`);
                const button = copySourceCandidate?.cloneNode(true) || toneButton;
                block.label && (button.ariaLabel = block.label);
                if (block.tone.tonePitch) {
                    if (block.label !== '無調整') {
                        button.classList.remove('material-icons');
                        button.textContent = block.label;
                    }
                    button.dataset.tone = block.tone.tone;
                    if (copySourceCandidate) {
                        copySourceCandidate.replaceWith(button.cloneNode(true));
                    } else {
                        tonesUl.appendChild(button.cloneNode(true));
                    }
                    button.dataset.tonePitch = block.tone.tonePitch
                    noteCount++;
                }
                block.tempo && (button.dataset.tempo = block.tempo);
                block.noteValue && (button.dataset.noteValue = block.noteValue);
                block.rest && (button.dataset.rest = block.rest);
                block.octave && (button.dataset.octave = block.octave);
                block.velocity && (button.dataset.velocity = block.velocity);
                block.noteShift && (button.dataset.noteShift = block.noteShift);
                block.detune && (button.dataset.detune = block.detune);
                block.loopStart && (button.dataset.loopStart = block.loopStart);
                block.loopBreak && (button.dataset.loopBreak = block.loopBreak);
                block.loopEnd && (button.dataset.loopEnd = block.loopEnd);
                block.usingPoly && (button.dataset.usingPoly = block.usingPoly);
                block.polyStartEnd && (button.dataset.polyStartEnd = block.polyStartEnd);
                if (block.otherAction) {
                    button.dataset.otherAction = block.otherAction;
                    button.textContent = block.otherAction;
                }
                li.appendChild(button);
                ul.appendChild(li);
            });
        }

        exportMml(mml) {
            mml.setMmlArr([]);
            let lineIndex = 0;
            let toneArr = this.#blocksData.filter(block => block.tone.tone !== undefined).map(block => block.tone.tone);
            let toneSet = new Set(toneArr);
            let toneAppended = false;
            this.#blocksData.forEach(block => {
                const {tone, tonePitch} = block.tone;
                if (tone !== undefined) {
                    const toneIndex = [...toneSet].indexOf(tone);
                    if (!toneAppended) {
                        [...toneSet].forEach((tone, i) => {
                            tone !== '' && mml.beforeInsertToStr(lineIndex + i, tone + ' ');
                        });
                        toneAppended = true;
                    }
                    [...toneSet].forEach((_, i) => {
                        let mmlText = tonePitch || '';
                        if (i !== toneIndex) {
                            const noteValue = (/[0-9]+/.exec(mmlText) || [''])[0];
                            mmlText = 'r' + noteValue;
                        }
                        mml.appendToStr(lineIndex + i, mmlText);
                    });
                } else {
                    if (block.noteValue || block.loopStart || block.loopBreak || block.loopEnd) {
                        [...toneSet].forEach((_, i) => {
                            mml.appendToStr(lineIndex + i, block.noteValue || block.loopStart || block.loopBreak || block.loopEnd || '');
                        });
                    } else {
                        mml.appendToStr(lineIndex, tonePitch || block.tempo || block.noteValue || block.rest
                            || block.octave || block.velocity || block.noteShift || block.detune
                            || block.loopStart || block.loopBreak || block.loopEnd || block.usingPoly
                            || block.polyStartEnd || block.otherAction || '');
                        if (mml.getMmlLine(lineIndex).includes('\n')) {
                            const mmlText = mml.getMmlLine(lineIndex).replace('\n', '');
                            mml.rewrite(lineIndex, mmlText);
                            lineIndex++;
                        }
                    }
                }
            });
            [...toneSet].forEach((_, i) => {
                mml.appendToStr(lineIndex + i, ';');
            });
        }

        importMml(mml) {
            const mmlArr = mml.getMmlArr();
            const regex = /@.* |[><]*?[a-g]\+?[0-9]*|t[0-9]+|l[0-9]+|r[0-9]*|o[0-8]|@v[0-9]+|@ns[0-9]+|@d[0-9]+|\/:[0-9]*|:\/|\/|#USING POLY [0-9]+ force|\[|\]|.*/g;
            /* tone.tone|tone.tonePitch|tempo|noteValue|rest|octave|velocity|noteShift|detune|loopStart|loopEnd|loopBreak|usingPoly|polyStartEnd|otherAction */
            const data = [];
            let noteCount = 0;
            mmlArr.forEach(mmlTextLine => {
                const matched = mmlTextLine.match(regex);
                let toneCache = '';
                (matched || []).forEach(str => {
                    if (!str) {
                        return;
                    }
                    const obj = {};
                    obj.tone = {};
                    if (str.startsWith('@')) {
                        toneCache = str.trim();
                        noteCount++;
                        return;
                    } else if (/^[><]*?[a-g]\+?[0-9]*$/.test(str)) {
                        obj.label = '無調整';
                        !noteCount && noteCount++;
                        obj.className = `material-icons note note-${noteCount}`;
                        obj.tone.tone = toneCache;
                        obj.tone.tonePitch = str;
                    } else if (str.startsWith('t')) {
                        obj.className = 'material-icons tempo';
                        obj.tempo = str;
                    } else if (str.startsWith('l')) {
                        obj.className = 'material-icons note-value';
                        obj.noteValue = str;
                    } else if (str.startsWith('r')) {
                        obj.className = 'material-icons rest';
                        obj.rest = str;
                    } else if (str.startsWith('o')) {
                        obj.className = 'material-icons octave';
                        obj.octave = str;
                    } else if (str.startsWith('@v')) {
                        obj.className = 'material-icons velocity';
                        obj.velocity = str;
                    } else if (str.startsWith('@ns')) {
                        obj.className = 'material-icons note-shift';
                        obj.noteShift = str;
                    } else if (str.startsWith('@d')) {
                        obj.className = 'material-icons detune';
                        obj.detune = str;
                    } else if (str.startsWith('/:')) {
                        obj.className = 'loop-start';
                        obj.loopStart = str;
                    } else if (str.startsWith(':/')) {
                        obj.className = 'material-icons loop-end';
                        obj.loopEnd = str;
                    } else if (str.startsWith('/')) {
                        obj.className = 'loop-break';
                        obj.loopBreak = str;
                    } else if (str.startsWith('#USING POLY ')) {
                        obj.className = 'using-poly';
                        obj.usingPoly = str + '\n';
                    } else if (str.startsWith('[') || str.startsWith(']')) {
                        obj.className = 'poly-start-end';
                        obj.polyStartEnd = str;
                    } else if (str.startsWith(';')) {
                        return;
                    } else {
                        obj.className = 'other-action';
                        obj.otherAction = str;
                    }
                    data.push(obj);
                });
            });
            this.tonesElem.querySelector('ul').textContent = '';
            this.areaElem.querySelector('ul').textContent = '';
            lastTouchedButton = null;
            this.#blocksData = data;
            this.parseBlocks();
            this.blocksDataUpdate();
            this.calcPoly();
        }

        playRendering() {
            const data = this.#blocksData;
            let tempo = 120;
            let scoreNoteValue = 4;
            let skip = false, jump = false, nest = 0;
            let loopStart = -1, loopEnd = -1, remainingLoop = 0;
            let i = 0;
            [tones, action, musicalScore].forEach(target => {
                target.classList.add('no-op');
            });
            const delayAttachMotion = noteValue => {
                this.#rendTimeout = setTimeout(attachMotion,
                    60 / tempo * 4 / noteValue * 1000);
            };
            const attachMotion = () => {
                const current = data[i];
                if (!current || i >= current.length) {
                    return;
                } else if (jump) {
                    if (current.loopStart) {
                        nest++;
                    } else if (current.loopEnd) {
                        nest--;
                        if (!nest) {
                            resetAnimation(current.elem, 'pop');
                            jump = false;
                        }
                    }
                    i++;
                    attachMotion();
                } else if (current.tone.tonePitch) {
                    const currentNoteValue = Number(current.tone.tonePitch.replace(/[><]*[a-g]\+?/, '')) || scoreNoteValue;
                    resetAnimation(current.elem, 'bounce');
                    i++;
                    if (!skip) {
                        delayAttachMotion(currentNoteValue);
                    } else {
                        attachMotion();
                    }
                } else if (current.rest) {
                    const currentNoteValue = Number(current.rest.replace('r', '')) || scoreNoteValue;
                    resetAnimation(current.elem, 'pop');
                    i++;
                    delayAttachMotion(currentNoteValue);
                } else {
                    current.tempo && (tempo = Number(current.tempo.replace('t', '')) || tempo);
                    current.noteValue && (scoreNoteValue = Number(current.noteValue.replace('l', '')) || scoreNoteValue);
                    current.polyStartEnd && (skip = current.polyStartEnd === '[');
                    resetAnimation(current.elem, 'pop');
                    if (current.loopStart) {
                        loopStart = i;
                        if (!remainingLoop && loopStart > loopEnd) {
                            remainingLoop = current.loopStart.replace('/:', '');
                            remainingLoop === '' ? (remainingLoop = 2) : (remainingLoop = Number(remainingLoop));
                            if (!remainingLoop) {
                                jump = true;
                                nest++;
                            }
                        };
                        i++;
                    } else if (current.loopBreak) {
                        if (remainingLoop === 1) {
                            i = loopEnd;
                            remainingLoop--;
                        }
                        i++;
                    } else if (current.loopEnd) {
                        loopEnd = i;
                        remainingLoop--;
                        if (remainingLoop) {
                            i = loopStart;
                        } else {
                            i++;
                        }
                    } else {
                        i++;
                    }
                    attachMotion();
                }
                resetAnimation(current.elem, 'done');
            }
            attachMotion();
        }

        stopRendering() {
            [tones, action, musicalScore].forEach(target => {
                target.classList.remove('no-op');
            });
            this.#blocksData.forEach(block => {
                block.elem.classList.remove('done');
            });
            clearTimeout(this.#rendTimeout);
        }

        calcPoly() {
            const polyBlocksData = this.#blocksData.filter(block => block.polyStartEnd);
            polyBlocksData.forEach((block, i) => {
                if (i % 2 === 0) {
                    block.elem.dataset.polyStartEnd = '[';
                    block.elem.textContent = '[';
                } else {
                    block.elem.dataset.polyStartEnd = ']';
                    block.elem.textContent = ']';
                }
            });
            this.blocksDataUpdate();
        }
    }

    class History {
        #histArr = [[],[]];
        #maxArrLength = 70;
        #popstateHandler = obj => {};

        set onPopstate(fn) {
            this.#popstateHandler = fn;
        }

        pushState(obj) {
            this.#histArr[0].push(obj);
            if (this.#histArr[0].length > this.#maxArrLength) {
                this.#histArr[0].shift();
            }
            this.#histArr[1].length = 0;
            console.log(this.#histArr);
        }

        undo() {
            const data = this.#histArr[0].pop();
            this.#popstateHandler({
                reason: 'undo',
                data
            });
            data && this.#histArr[1].unshift(data);
            console.log(this.#histArr);
        }

        redo() {
            const data = this.#histArr[1].shift();
            this.#popstateHandler({
                reason: 'redo',
                data
            });
            data && this.#histArr[0].push(data);
            console.log(this.#histArr);
        }

        clear() {
            this.#histArr[0].length = 0;
            this.#histArr[1].length = 0;
            console.log(this.#histArr);
        }
    }

    class DialogFormManager {
        #dialogDefinitions = {
            tone: {
                title: '音色設定',
                inputs: [
                    {
                        label: '名前',
                        type: 'text',
                        name: 'tone-name'
                    },
                    {
                        label: '音の定義',
                        type: 'text',
                        name: 'tone-def',
                        autofocus: ''
                    },
                ],
                buttons: [
                    {
                        class: 'primaly',
                        value: 'set-tone',
                        textContent: '確定'
                    }
                ]
            },
            tonePitch: {
                title: '音価設定',
                inputs: [
                    {
                        label: '音価(音の長さ)',
                        type: 'number',
                        name: 'tone-pitch',
                        min: '1',
                        max: '384'
                    }
                ],
                buttons: [
                    {
                        class: 'primaly',
                        value: 'set-tone-pitch',
                        textContent: '確定'
                    }
                ]
            },
            tempo: {
                title: 'テンポ設定',
                inputs: [
                    {
                        label: 'テンポ指定(BPM)',
                        type: 'number',
                        name: 'tempo',
                        min: '0'
                    }
                ],
                buttons: [
                    {
                        class: 'primaly',
                        value: 'set-tempo',
                        textContent: '確定'
                    }
                ]
            },
            noteValue: {
                title: '音価設定',
                inputs: [
                    {
                        label: '音価(音の長さ)',
                        type: 'number',
                        name: 'note-value',
                        min: '1',
                        max: '384'
                    }
                ],
                buttons: [
                    {
                        class: 'primaly',
                        value: 'set-note-value',
                        textContent: '確定'
                    }
                ]
            },
            rest: {
                title: '休符設定',
                inputs: [
                    {
                        label: '休符の長さ',
                        type: 'number',
                        name: 'rest',
                        min: '1',
                        max: '384'
                    }
                ],
                buttons: [
                    {
                        class: 'primaly',
                        value: 'set-rest',
                        textContent: '確定'
                    }
                ]
            },
            octave: {
                title: 'オクターブ設定',
                inputs: [
                    {
                        label: 'オクターブ位置',
                        type: 'number',
                        name: 'octave',
                        min: '0',
                        max: '8'
                    }
                ],
                buttons: [
                    {
                        class: 'primaly',
                        value: 'set-octave',
                        textContent: '確定'
                    }
                ]
            },
            velocity: {
                title: '音量設定',
                inputs: [
                    {
                        label: '音量',
                        type: 'number',
                        name: 'velocity',
                        min: '0',
                        max: '127'
                    }
                ],
                buttons: [
                    {
                        class: 'primaly',
                        value: 'set-velocity',
                        textContent: '確定'
                    }
                ]
            },
            noteShift: {
                title: 'ノートシフト設定',
                inputs: [
                    {
                        label: 'シフト量',
                        type: 'number',
                        name: 'note-shift'
                    }
                ],
                buttons: [
                    {
                        class: 'primaly',
                        value: 'set-note-shift',
                        textContent: '確定'
                    }
                ]
            },
            detune: {
                title: 'デチューン設定',
                inputs: [
                    {
                        label: 'デチューン量',
                        type: 'number',
                        name: 'detune'
                    }
                ],
                buttons: [
                    {
                        class: 'primaly',
                        value: 'set-detune',
                        textContent: '確定'
                    }
                ]
            },
            loop: {
                title: 'ループ設定',
                inputs: [
                    {
                        label: 'ループ回数',
                        type: 'number',
                        name: 'loop',
                        min: '0'
                    }
                ],
                buttons: [
                    {
                        class: 'primaly',
                        value: 'set-loop',
                        textContent: '確定'
                    }
                ]
            },
            usingPoly: {
                title: '和音設定',
                inputs: [
                    {
                        label: '和音重ね数',
                        type: 'number',
                        name: 'using-poly',
                        min: '1'
                    }
                ],
                buttons: [
                    {
                        class: 'primaly',
                        value: 'set-using-poly',
                        textContent: '確定'
                    }
                ]
            },
            metaData: {
                title: 'メタデータ設定',
                inputs: [
                    {
                        label: '定義選択',
                        select: {
                            '#TITLE {desc}\n': 'タイトル',
                            '#ARTIST {desc}\n': 'アーティスト',
                            '#COMMENT {desc}\n': 'コメント',
                            '#CODING {desc}\n': '作成者',
                            '#PRAGMA {desc}\n': 'PRAGMA',
                            '#OCTAVE REVERSE\n': '相対オクターブ反転',
                            '#VELOCITY REVERSE\n': '相対ベロシティ反転',
                            '#WAV9 {n},{desc}\n': '@9 波形データ',
                            '#WAV10 {n},{desc}\n': '@10 波形データ',
                            '#WAV13 {n},{desc}\n': '@13 波形データ',
                            '#OPM@{n} {{desc}}\n': '@14 OPM音色データ',
                            '#OPN@{n} {{desc}}\n': '@14 OPN音色データ',
                            '#FMGAIN {n}\n': '@14 音量利得',
                            '#USING POLY {n} force\n': '和音利用宣言',
                        },
                        name: 'select-meta-data'
                    },
                    {
                        label: '数',
                        type: 'number',
                        name: 'number'
                    },
                    {
                        label: '文字列',
                        type: 'text',
                        name: 'text'
                    },
                ],
                buttons: [
                    {
                        class: 'primaly',
                        value: 'set-meta-data',
                        textContent: '確定'
                    }
                ]
            },
            macroDef: {
                title: 'マクロ定義設定',
                inputs: [
                    {
                        label: '名前(+引数)',
                        type: 'text',
                        name: 'macro-def-name'
                    },
                    {
                        label: '内容',
                        type: 'text',
                        name: 'macro-def-desc'
                    },
                ],
                buttons: [
                    {
                        class: 'primaly',
                        value: 'set-macro-def',
                        textContent: '確定'
                    }
                ]
            },
            macroUse: {
                title: 'マクロ使用設定',
                inputs: [
                    {
                        label: '名前',
                        type: 'text',
                        name: 'macro-use-name'
                    },
                    {
                        label: '引数(あれば)',
                        type: 'text',
                        name: 'macro-use-arg'
                    },
                ],
                buttons: [
                    {
                        class: 'primaly',
                        value: 'set-macro-use',
                        textContent: '確定'
                    }
                ]
            },
            otherAction: {
                title: 'その他の作用設定',
                inputs: [
                    {
                        label: '任意のMML',
                        type: 'text',
                        name: 'other-action'
                    }
                ],
                buttons: [
                    {
                        class: 'primaly',
                        value: 'set-other-action',
                        textContent: '確定'
                    }
                ]
            }
        }
        #createElems = (type) => {
            const def = this.#dialogDefinitions[type];
            Object.keys(def).forEach(key => {
                switch (key) {
                    case 'title':
                        dialogForm._title.textContent = def.title;
                        break;
                    case 'inputs':
                        def.inputs.forEach(inputDef => {
                            const input = document.createElement('input');
                            let appendElem = input;
                            Object.entries(inputDef).forEach(entry => {
                                if (entry[0] === 'label') {
                                    const label = document.createElement('label');
                                    label.innerHTML = entry[1];
                                    label.appendChild(input);
                                    appendElem = label;
                                } else if (entry[0] === 'select') {
                                    const select = document.createElement('select');
                                    select.name = inputDef.name;
                                    const selectOptionsDef = entry[1];
                                    Object.entries(selectOptionsDef).forEach(entry => {
                                        const option = document.createElement('option');
                                        option.value = entry[0];
                                        option.textContent = entry[1];
                                        select.appendChild(option);
                                    });
                                    input.replaceWith(select);
                                } else {
                                    input.setAttribute(entry[0], entry[1]);
                                }
                            });
                            dialogForm.inputs.appendChild(appendElem);
                        });
                        break;
                    case 'buttons':
                        def.buttons.forEach(buttonDef => {
                            const button = document.createElement('button');
                            Object.entries(buttonDef).forEach(entry => {
                                if (entry[0] === 'textContent') {
                                    button.textContent = entry[1];
                                } else {
                                    button.setAttribute(entry[0], entry[1]);
                                }
                            });
                            dialogForm.buttons.appendChild(button);
                        });
                        break;
                }
            });
        }

        #set = (type, initVals) => {
            dialogForm._title.textContent = '';
            dialogForm.inputs.textContent = '';
            dialogForm.buttons.textContent = '';
            this.#createElems(type);
            for (const [name, value] of Object.entries(initVals)) {
                if (name === 'run') {
                    value();
                } else {
                    dialogForm.elements[name].value = value;
                }
            }
            this.type = type;
        }

        constructor() {
            this.type = null;
            this.submitTarget = null;
            this.resolve = null;
        }

        async prompt(type, initVals, submitTarget) {
            this.#set(type, initVals);
            this.submitTarget = submitTarget;
            dialog.showModal();
            return new Promise(resolve => this.resolve = resolve);
        }
    }

    FlMML.prepare(`.editor`);
    const flmml = new FlMML({workerURL: FlMMLWorkerLocation});
    const mml = new Mml();
    localForage.config({
        name        : 'FlMML-VisualSequencer',
        version     : 1.0,
        storeName   : 'backups',
        description : 'BlockData Object Backups'
    });
    const block = new Block(tones, musicalScore);
    const history = new History();
    const dialogFormManager = new DialogFormManager();
    const ja = {
        "categories": {
            "custom": "カスタム",
            "smileys-emotion": "スマイリーと感情",
            "people-body": "人々と体",
            "animals-nature": "動物と自然",
            "food-drink": "食べ物と飲み物",
            "travel-places": "旅行と場所",
            "activities": "活動",
            "objects": "オブジェクト",
            "symbols": "シンボル",
            "flags": "フラグ"
        },
        "categoriesLabel": "カテゴリー",
        "emojiUnsupportedMessage": "お使いのブラウザはカラー絵文字に対応していません。",
        "favoritesLabel": "お気に入り",
        "loadingMessage": "読み込み中…",
        "networkErrorMessage": "絵文字を読み込めませんでした。",
        "regionLabel": "絵文字ピッカー",
        "searchDescription": "検索結果が利用可能な場合、上下キーを押して選択し、Enter キーを押して選択します。",
        "searchLabel": "検索",
        "searchResultsLabel": "検索結果",
        "skinToneDescription": "展開された状態で、上下キーを押して選択し、Enter キーを押して選択します。",
        "skinToneLabel": "スキントーンを選択してください（現在のスキントーンは {skinTone} です）",
        "skinTones": [
            "デフォルト",
            "ライト",
            "ミディアムライト",
            "ミディアム",
            "ミディアムダーク",
            "ダーク"
        ],
        "skinTonesLabel": "スキントーン"
    }
    const picker = new Picker({
        i18n: ja,
        locale: 'ja'
    });
    polyfill();
    useVisualViewportToCss();

    const createMIsHtml = name => `<span class="material-icons">${name}</span>`;
    const playHtml = createMIsHtml('play_arrow') + '再生';
    const stopHtml = createMIsHtml('stop') + '停止';

    const playAnimationStart = () => {
        block.playRendering();
    };
    const compileHandler = () => {
        warnOut.innerHTML = flmml.getWarnings().replaceAll('\n','<br>');
    };
    flmml.addEventListener('compilecomplete', compileHandler);
    const completeHandler = () => {
        playBtn.innerHTML = playHtml;
        block.stopRendering();
        flmml.removeEventListener('compilecomplete', playAnimationStart);
    };
    flmml.addEventListener('complete', completeHandler);

    mml.onChange = (arr, mmlText) => {
        mmlOut.innerHTML = mmlText ? `<pre><code>${htmlspecialchars(mmlText).replaceAll('\n','<br>')}</code></pre>` : '(なし)';
        const mmlIsExist = Boolean(arr.length);
        [mmlForm.del.field, mmlForm.rw.field, copyBtn, saveBtn].forEach(elem => {
            elem.disabled = !mmlIsExist;
        });
        if (mmlIsExist) {
            mmlForm.del.index.max = arr.length - 1;
            mmlForm.rw.index.max = arr.length - 1;
            mmlForm.del.index.value > mmlForm.del.index.max && (mmlForm.del.index.value = mmlForm.del.index.max);
            mmlForm.rw.index.value > mmlForm.rw.index.max && (mmlForm.rw.index.value = mmlForm.rw.index.max);
        }
    };
    mml.onError = (error, reason) => {
        alert(error + '\n' + reason);
    };

    block.checkSavedBlocksData();

    const playMusicNote = block => {
        const findOctaveElem = () => {
            let findTemp = block.parentElement;
            while (findTemp && !('octave' in findTemp.firstElementChild.dataset)) {
                findTemp = findTemp.previousElementSibling;
            };
            return findTemp?.firstElementChild || null;
        };
        const absoluteOctaveMml = findOctaveElem()?.dataset.octave || '';
        const currentIndex = [...musicalScore.querySelector('ul').children].indexOf(block.parentElement);
        const concatAllOctave = [...musicalScore.querySelector('ul').children]
                                    .slice(0, currentIndex)
                                    .filter(li => 'tonePitch' in li.firstElementChild.dataset)
                                    .map(li => {
                                        const pitch = li.firstElementChild.dataset.tonePitch;
                                        return (pitch.match(/[><]+/) || [''])[0];
                                    }).join('');
        const octave = ['>', '<'];
        const countStr = (target, str) => (target.match(new RegExp(str, 'g')) || []).length;
        const currentRelativeOctave = (() => {
            const relativeOctaveNum = -countStr(concatAllOctave, octave[0]) + countStr(concatAllOctave, octave[1]);
            if (relativeOctaveNum < 0) {
                return octave[0].repeat(-relativeOctaveNum);
            } else if (relativeOctaveNum > 0) {
                return octave[1].repeat(relativeOctaveNum);
            } else {
                return '';
            }
        })();
        flmml.play(block.dataset.tone + absoluteOctaveMml + currentRelativeOctave + block.dataset.tonePitch);
    };

    history.onPopstate = obj => {
        const data = obj.data;
        const is = id => Boolean(data.parent.closest('#' + id));
        switch (obj.reason) {
            case 'undo':
                switch (data?.operation) { //元に戻す操作集
                    case 'append':
                        mml.delete(data.index);
                        break;
                    case 'delete':
                        mml.insert(data.index, data.mmlText);
                        break;
                    case 'rewrite':
                        mml.rewrite(data.index, data.beforeMmlText);
                        break;
                    case 'copy':
                        data.newElem.remove();
                        if (is('musical-score')) {
                            block.blocksDataUpdate();
                            block.calcPoly();
                            block.saveBlocksData();
                            block.exportMml(mml);
                        }
                        break;
                    case 'move':
                        const position = data.fromIndex <= data.toIndex ? 'beforebegin' : 'afterend';
                        data.parent.children[data.fromIndex].insertAdjacentElement(position, data.elem);
                        if (is('musical-score')) {
                            block.blocksDataUpdate();
                            block.calcPoly();
                            block.saveBlocksData();
                            block.exportMml(mml);
                        }
                        break;
                    case 'valueChange':
                        for (const [name, value] of Object.entries(data.beforeChange)) {
                            data.target.dataset[name] = value;
                        }
                        if ('tone' in data.target.dataset) {
                            playMusicNote(data.target);
                        }
                        block.blocksDataUpdate();
                        block.saveBlocksData();
                        block.exportMml(mml);
                        break;
                    case 'remove':
                        data.parent.insertBefore(data.removedElem, data.parent.children[data.removedIndex]);
                        if (is('tones')) { //TODO
                        } else if (is('musical-score')) {
                            block.blocksDataUpdate();
                            block.calcPoly();
                            block.saveBlocksData();
                            block.exportMml(mml);
                        }
                        break;
                    case 'clear':
                        data.tonesChildren.forEach(li => {
                            tones.querySelector('ul').appendChild(li);
                        });
                        data.musicalScoreChildren.forEach(li => {
                            musicalScore.querySelector('ul').appendChild(li);
                        });
                        lastTouchedButton = data.lastTouchedButton;
                        block.blocksDataUpdate();
                        block.saveBlocksData();
                        block.exportMml(mml);
                        break;
                }
                break;
            case 'redo':
                switch (data?.operation) { //やり直し操作集
                    case 'append':
                        mml.append(data.mmlText);
                        break;
                    case 'delete':
                        mml.delete(data.index);
                        break;
                    case 'rewrite':
                        mml.rewrite(data.index, data.afterMmlText);
                        break;
                    case 'copy':
                        if (data.toIndex !== -1) {
                            data.parent.insertBefore(data.newElem, data.parent.children[data.toIndex]);
                        } else {
                            data.parent.appendChild(data.newElem);
                        }
                        if (is('musical-score')) {
                            block.blocksDataUpdate();
                            block.calcPoly();
                            block.saveBlocksData();
                            block.exportMml(mml);
                        }
                        if ('tonePitch' in lastTouchedButton.dataset) {
                            playMusicNote(lastTouchedButton);
                            lastTouchedButton.classList.add('bounce');
                        }
                        break;
                    case 'move':
                        const position = data.toIndex > data.fromIndex ? 'beforebegin' : 'afterend';
                        data.parent.children[data.fromIndex].insertAdjacentElement(position, data.elem);
                        if (is('musical-score')) {
                            block.blocksDataUpdate();
                            block.calcPoly();
                            block.saveBlocksData();
                            block.exportMml(mml);
                        }
                        break;
                    case 'valueChange':
                        for (const [name, value] of Object.entries(data.afterChange)) {
                            data.target.dataset[name] = value;
                        }
                        if ('tone' in data.target.dataset) {
                            playMusicNote(data.target);
                        }
                        block.blocksDataUpdate();
                        block.saveBlocksData();
                        block.exportMml(mml);
                        break;
                    case 'remove':
                        const buttonClassName = data.removedElem.className;
                        data.removedElem.remove();
                        if (is('tones')) {
                            musicalScore.querySelectorAll(`[class="${buttonClassName}"]`).forEach(elem => {
                                elem.parentElement.remove();
                            });
                        }
                        block.blocksDataUpdate();
                        block.calcPoly();
                        block.saveBlocksData();
                        block.exportMml(mml);
                        break;
                    case 'clear':
                        tones.querySelector('ul').textContent = '';
                        musicalScore.querySelector('ul').textContent = '';
                        lastTouchedButton = null;
                        block.blocksDataUpdate();
                        block.saveBlocksData();
                        block.exportMml(mml);
                        break;
                }
                break;
        }
    };

    const getNonExistNoteClassName = () => {
        const noteClassNames = [...tones.getElementsByTagName('button')].map(elem => [...elem.classList].find(name => name.includes('note-')));
        for (let index = 1; ; index++) {
            if (!noteClassNames.includes('note-' + index)) {
                return 'note-' + index;
            }
        }
    };

    document.addEventListener('keydown', e => {
        const ctrlKey = e.ctrlKey || ctrlBtn.pressed;
        switch (e.key.toLowerCase()) {
            case ' ':
                if (document.activeElement.tagName.toLowerCase() !== 'input') { // contentEditableのことは考えていない
                    e.preventDefault();
                    playBtn.click();
                }
                break;
            case 'z':
                ctrlKey && history.undo();
                break;
            case 'y':
                ctrlKey && history.redo();
                break;
        }
    });

    const actionPromptSwitcher = async item => {
        if ('tempo' in item.dataset) {
            await dialogFormManager.prompt('tempo', {
                'tempo': item.dataset.tempo.replace('t', '')
            }, item);
        } else if ('noteValue' in item.dataset) {
            await dialogFormManager.prompt('noteValue', {
                'note-value': item.dataset.noteValue.replace('l', '')
            }, item);
        } else if ('rest' in item.dataset) {
            await dialogFormManager.prompt('rest', {
                'rest': item.dataset.rest.replace('r', '')
            }, item);
        } else if ('octave' in item.dataset) {
            await dialogFormManager.prompt('octave', {
                'octave': item.dataset.octave.replace('o', '')
            }, item);
        } else if ('velocity' in item.dataset) {
            await dialogFormManager.prompt('velocity', {
                'velocity': item.dataset.velocity.replace('@v', '')
            }, item);
        } else if ('noteShift' in item.dataset) {
            await dialogFormManager.prompt('noteShift', {
                'note-shift': item.dataset.noteShift.replace('@ns', '')
            }, item);
        } else if ('detune' in item.dataset) {
            await dialogFormManager.prompt('detune', {
                'detune': item.dataset.detune.replace('@d', '')
            }, item);
        } else if ('loopStart' in item.dataset) {
            await dialogFormManager.prompt('loop', {
                'loop': item.dataset.loopStart.replace('/:', '')
            }, item);
        } else if ('loopEnd' in item.dataset) {
            const findLoopStartElem = () => {
                let findTemp = item.parentElement || musicalScore.querySelector('li:last-child');
                while (findTemp && !('loopStart' in findTemp.firstElementChild.dataset)) {
                    findTemp = findTemp.previousElementSibling;
                };
                return findTemp?.firstElementChild || null;
            };
            item = findLoopStartElem();
            const loopStartCount = musicalScore.getElementsByClassName('loop-start').length;
            const loopEndCount = musicalScore.getElementsByClassName('loop-end').length;
            const enoughLoopEnds = loopStartCount === loopEndCount;
            const parentMusicalScore = item.closest('#musical-score');
            if (!item || enoughLoopEnds && !parentMusicalScore) {
                const ul = musicalScore.querySelector('ul');
                const li = document.createElement('li');
                const baseItem = action.querySelector('.loop-start');
                const newItem = baseItem.cloneNode(true);
                li.appendChild(newItem);
                ul.appendChild(li);
                item = newItem;
            }
            await dialogFormManager.prompt('loop', {
                'loop': item.dataset.loopStart.replace('/:', '')
            }, item);
        } else if ('usingPoly' in item.dataset) {
            await dialogFormManager.prompt('usingPoly', {
                'using-poly': item.dataset.usingPoly.replace('#USING POLY ', '').replace(' force\n', '')
            }, item);
        } else if ('metaData' in item.dataset) {
            await dialogFormManager.prompt('metaData', {}, item);
        } else if ('otherAction' in item.dataset) {
            await dialogFormManager.prompt('otherAction', {
                'other-action': item.dataset.otherAction
            }, item);
        }
    };
    let lastTouchedButton = tones.querySelector('button');
    editor.addEventListener('click', async e => {
        const ctrlKey = e.ctrlKey || ctrlBtn.pressed;
        const is = id => Boolean(e.target.closest('#' + id));
        const isButton =  e.target.tagName.toLowerCase() === 'button';
        if ([tones, action, musicalScore].some(target => target.classList.contains('no-op'))) {
            return;
        } else if (is('tones')) {
            if (isButton) {
                lastTouchedButton = e.target;
                await dialogFormManager.prompt('tone', {
                    'tone-name': e.target.ariaLabel,
                    'tone-def': e.target.dataset.tone,
                    'run': () => {
                        const toneName = dialogForm.elements['tone-name'];
                        toneName.insertAdjacentElement('afterend', picker);
                        const pickerElem = document.querySelector('emoji-picker');
                        toneName.addEventListener('focus', () => {
                            pickerElem.classList.add('expaned');
                        }, {once: true});
                        pickerElem.addEventListener('emoji-click', e => toneName.value = e.detail.unicode);
                    }
                }, e.target);
                flmml.play(e.target.dataset.tone + e.target.dataset.tonePitch);
                block.blocksDataUpdate();
                block.saveBlocksData();
                block.exportMml(mml);
            } else {
                const ul = tones.querySelector('ul');
                const li = document.createElement('li');
                const nonExistClassName = getNonExistNoteClassName();
                const toneButton = `<button class="material-icons note ${nonExistClassName}" aria-label="無調整" draggable="true" data-tone="" data-tone-pitch="c">music_note</button>`;
                li.innerHTML = toneButton;
                const newItem = li.firstElementChild;
                ul.appendChild(li);
                lastTouchedButton = newItem;
                flmml.play(newItem.dataset.tone + newItem.dataset.tonePitch);
                history.pushState({
                    operation: 'copy',
                    toIndex: -1,
                    newElem: li,
                    parent: ul
                });
            }
        } else if (is('action')) {
            if (isButton) {
                if ('otherAction' in e.target.dataset) {
                    await actionPromptSwitcher(e.target);
                }
                const ul = musicalScore.querySelector('ul');
                const li = document.createElement('li');
                const newItem = e.target.cloneNode(true);
                li.appendChild(newItem);
                ul.appendChild(li);
                lastTouchedButton = newItem;
                block.blocksDataUpdate();
                block.calcPoly();
                block.saveBlocksData();
                block.exportMml(mml);
                history.pushState({
                    operation: 'copy',
                    toIndex: -1,
                    newElem: li,
                    parent: ul
                });
            }
        } else if (is('musical-score')) {
            if (isButton) {
                if ('tone' in e.target.dataset) {
                    playMusicNote(e.target);
                    resetAnimation(e.target, 'bounce');
                    if (ctrlKey) {
                        await dialogFormManager.prompt('tonePitch', {
                            'tone-pitch': e.target.dataset.tonePitch.replace(/[><]*[a-g]\+?/, '')
                        }, e.target);
                        flmml.play(e.target.dataset.tone + absoluteOctaveMml + currentRelativeOctave + e.target.dataset.tonePitch);
                    }
                } else {
                    await actionPromptSwitcher(e.target);
                }
                lastTouchedButton = e.target;
                block.blocksDataUpdate();
                block.saveBlocksData();
                block.exportMml(mml);
            } else {
                if (lastTouchedButton) {
                    const ul = musicalScore.querySelector('ul');
                    const li = document.createElement('li');
                    const newItem = lastTouchedButton.cloneNode(true);
                    li.appendChild(newItem);
                    ul.appendChild(li);
                    lastTouchedButton = newItem;
                    block.blocksDataUpdate();
                    block.calcPoly();
                    block.saveBlocksData();
                    block.exportMml(mml);
                    history.pushState({
                        operation: 'copy',
                        toIndex: -1,
                        newElem: li,
                        parent: ul
                    });
                    if ('tonePitch' in newItem.dataset) {
                        newItem.dataset.tonePitch = newItem.dataset.tonePitch.replace(/[><]+/, '');
                        playMusicNote(newItem);
                        newItem.classList.add('bounce');
                    }
                }
            }
        }
    });

    editor.addEventListener('contextmenu', e => {
        const parent = target => target.closest('#tones, #musical-score');
        const is = id => Boolean(e.target.closest('#' + id));
        const isButton =  e.target.tagName.toLowerCase() === 'button';
        if (parent(e.target)?.classList.contains('no-op')) {
            return;
        } else if (parent(e.target)) {
            const target = isButton ? e.target : lastTouchedButton;
            if (!target || parent(target) !== parent(e.target)) {
                return;
            }
            e.preventDefault();
            const removeTarget = target.parentElement;
            const buttonClassName = target.className;
            const removeTargetIndex = [...parent(target).querySelector('ul').children].indexOf(removeTarget);
            lastTouchedButton = removeTarget.previousElementSibling?.firstElementChild
                                || removeTarget.nextElementSibling?.firstElementChild
                                || null;
            history.pushState({
                operation: 'remove',
                removedElem: removeTarget,
                removedIndex: removeTargetIndex,
                parent: parent(target).querySelector('ul')
            });
            removeTarget.remove();
            if (is('tones')) {
                musicalScore.querySelectorAll(`[class="${buttonClassName}"]`).forEach(elem => {
                    elem.parentElement.remove();
                });
            }
            block.blocksDataUpdate();
            block.calcPoly();
            block.saveBlocksData();
            block.exportMml(mml);
        }
    });

    let lastY = null, ignoneTouch = false, dragJudgementTimer = null, doNotDrag = false;
    editor.addEventListener('touchstart', e => {
        const touchY = [...e.touches].at(-1).pageY;
        lastY = touchY;
        doNotDrag = true;
        dragJudgementTimer = setTimeout(() => {
            ignoneTouch = true;
            doNotDrag = false;
        }, 500);
    });
    const wheelHandler = e => {
        const ctrlKey = e.ctrlKey || ctrlBtn.pressed;
        const is = id => Boolean(e.target.closest('#' + id));
        const isButton =  e.target.tagName.toLowerCase() === 'button';
        if (e.type == 'touchmove') {
            const touchY = [...e.touches].at(-1).pageY;
            if (ignoneTouch) {
                e.cancelable && e.preventDefault();
                return;
            } else if (touchY - lastY < -20) {
                e.deltaY = -1;
                clearTimeout(dragJudgementTimer);
            } else if (touchY - lastY > 20) {
                e.deltaY = 1;
                clearTimeout(dragJudgementTimer);
            } else {
                e.cancelable && e.preventDefault();
                return;
            }
            lastY = touchY;
            ignoneTouch = true;
            setTimeout(() => ignoneTouch = false, 50);

        }
        const isPositive = e.deltaY < 0;
        let target = isButton ? e.target : lastTouchedButton?.closest('#musical-score') && lastTouchedButton;
        if (!target) {
            return;
        } else if (is('musical-score')) {
            if (musicalScore.classList.contains('no-op')) {
                return;
            }
            e.preventDefault();
            let beforeChange = JSON.parse(JSON.stringify(target.dataset));
            if (!ctrlKey && 'tone' in target.dataset) {
                const pitches = ['c','c+','d','d+','e','f','f+','g','g+','a','a+','b'];
                const octave = ['>', '<'];
                const currentPitch = target.dataset.tonePitch;
                const currentPitchIndex = pitches.findIndex(pitch => currentPitch.replace(/[><0-9]+/g, '') === pitch);
                const countStr = (target, str) => (target.match(new RegExp(str, 'g')) || []).length;
                const octaveCount = [
                    countStr(currentPitch, octave[0]),
                    countStr(currentPitch, octave[1])
                ];
                const octaveStr = octave[0].repeat(octaveCount[0]) + octave[1].repeat(octaveCount[1]);
                const noteValue = (currentPitch.match(/[0-9]+/) || [''])[0];
                if (isPositive) { // Up
                    if (currentPitchIndex === pitches.length - 1) {
                        if (octaveCount[0]) {
                            target.dataset.tonePitch = octaveStr.substring(1) + pitches.at(0) + noteValue;
                        } else {
                            target.dataset.tonePitch = octaveStr + octave[1] + pitches.at(0) + noteValue;
                        }
                    } else {
                        target.dataset.tonePitch = octaveStr + pitches[currentPitchIndex + 1] + noteValue;
                    }
                } else { // Down
                    if (currentPitchIndex === 0) {
                        if (octaveCount[1]) {
                            target.dataset.tonePitch = octaveStr.substring(1) + pitches.at(-1) + noteValue;
                        } else {
                            target.dataset.tonePitch = octaveStr + octave[0] + pitches.at(-1) + noteValue;
                        }
                    } else {
                        target.dataset.tonePitch = octaveStr + pitches[currentPitchIndex - 1] + noteValue;
                    }
                }
                playMusicNote(target);
            } else {
                const increaseBase = isPositive ? 1 : -1;
                const minmax = (current, min = -Infinity, max = Infinity) => current + increaseBase < min ? 0 : current + increaseBase > max ? 0 : increaseBase;
                if (ctrlKey && 'tonePitch' in target.dataset) {
                    const noteValue = Number(target.dataset.tonePitch.replace(/[><]*[a-g]\+?/, ''));
                    const increase = minmax(noteValue, 0, 384);
                    const newNoteValue = noteValue + increase !== 0 ? noteValue + increase : '';
                    target.dataset.tonePitch = target.dataset.tonePitch.replace(/[0-9]+/, '') + newNoteValue;
                    playMusicNote(target);
                } else if ('tempo' in target.dataset) {
                    const tempo = Number(target.dataset.tempo.replace('t', ''));
                    const increase = minmax(tempo, 0);
                    target.dataset.tempo = 't' + (tempo + increase * 10);
                } else if ('noteValue' in target.dataset) {
                    const noteValue = Number(target.dataset.noteValue.replace('l', ''));
                    const increase = minmax(noteValue, 1, 384);
                    target.dataset.noteValue = 'l' + (noteValue + increase);
                } else if ('rest' in target.dataset) {
                    const rest = Number(target.dataset.rest.replace('r', ''));
                    const increase = minmax(rest, 0, 384);
                    const newRest = rest + increase !== 0 ? rest + increase : '';
                    target.dataset.rest = 'r' + newRest;
                } else if ('octave' in target.dataset) {
                    const octave = Number(target.dataset.octave.replace('o', ''));
                    const increase = minmax(octave, 0, 8);
                    target.dataset.octave = 'o' + (octave + increase);
                } else if ('velocity' in target.dataset) {
                    const velocity = Number(target.dataset.velocity.replace('@v', ''));
                    const increase = minmax(velocity, 0, 127);
                    target.dataset.velocity = '@v' + (velocity + increase);
                } else if ('noteShift' in target.dataset) {
                    const noteShift = Number(target.dataset.noteShift.replace('@ns', ''));
                    const increase = increaseBase;
                    target.dataset.noteShift = '@ns' + (noteShift + increase);
                } else if ('detune' in target.dataset) {
                    const detune = Number(target.dataset.detune.replace('@d', ''));
                    const increase = increaseBase;
                    target.dataset.detune = '@d' + (detune + increase);
                } else if ('loopStart' in target.dataset) {
                    const loop = Number(target.dataset.loopStart.replace('/:', '') || -1);
                    const increase = minmax(loop, -1);
                    const newLoop = loop + increase !== -1 ? loop + increase : '';
                    target.dataset.loopStart = '/:' + newLoop;
                } else if ('loopEnd' in target.dataset) {
                    const findLoopStartElem = () => {
                        let findTemp = target.parentElement;
                        while (findTemp && !('loopStart' in findTemp.firstElementChild.dataset)) {
                            findTemp = findTemp.previousElementSibling;
                        };
                        return findTemp?.firstElementChild || null;
                    };
                    target = findLoopStartElem();
                    const loopStartCount = musicalScore.getElementsByClassName('loop-start').length;
                    const loopEndCount = musicalScore.getElementsByClassName('loop-end').length;
                    const enoughLoopEnds = loopStartCount === loopEndCount;
                    if (!target || enoughLoopEnds && !is('musical-score')) {
                        const ul = musicalScore.querySelector('ul');
                        const li = document.createElement('li');
                        const baseItem = action.querySelector('.loop-start');
                        const newItem = baseItem.cloneNode(true);
                        li.appendChild(newItem);
                        ul.appendChild(li);
                        target = newItem;
                    }
                    beforeChange = JSON.parse(JSON.stringify(target.dataset))
                    const loop = Number(target.dataset.loopStart.replace('/:', ''));
                    const increase = minmax(loop, -1);
                    const newLoop = loop + increase !== -1 ? loop + increase : '';
                    target.dataset.loopStart = '/:' + newLoop;
                } else if ('usingPoly' in target.dataset) {
                    const usingPoly = Number(target.dataset.usingPoly.replace('#USING POLY ', '').replace(' force\n', ''));
                    const increase = minmax(usingPoly, 1);
                    target.dataset.usingPoly = '#USING POLY ' + (usingPoly + increase) + ' force\n';
                }
            }
            const afterChange = JSON.parse(JSON.stringify(target.dataset));
            if (beforeChange !== afterChange) {
                history.pushState({
                    operation: 'valueChange',
                    target,
                    beforeChange,
                    afterChange
                });
            }
            lastTouchedButton = target;
            block.blocksDataUpdate();
            block.saveBlocksData();
            block.exportMml(mml);
        }
    };
    editor.addEventListener('wheel', wheelHandler);
    editor.addEventListener('touchmove', wheelHandler);
    editor.addEventListener('touchend', () => {
        ignoneTouch = false;
        doNotDrag = false;
    });

    let dragInfo = {};
    editor.addEventListener('dragstart', e => {
        const editorSectionElem = e.target.nodeType === 1/* ELEMENT */ && e.target.closest('#tones, #action, #musical-score');
        dragInfo = {
            from: editorSectionElem,
            item: e.target
        };
        e.dataTransfer.effectAllowed = 'copyMove';
    });
    let dropEffect = null;
    [tones, action, musicalScore].forEach(target => {
        const dragEventHandler = e => {
            if (doNotDrag) {
                return;
            }
            const ctrlKey = e.ctrlKey || ctrlBtn.pressed;
            const {from = null} = dragInfo;
            const dt = e.dataTransfer;
            switch (from) {
                case tones:
                    switch (target) {
                        case tones:
                            e.preventDefault();
                            if (!ctrlKey) {
                                dt.dropEffect = 'move';
                            } else {
                                dt.dropEffect = 'copy';
                            }
                            break;
                        case action:
                            break;
                        case musicalScore:
                            e.preventDefault();
                            dt.dropEffect = 'copy';
                            break;
                    }
                    break;
                case action:
                    switch (target) {
                        case tones:
                            break;
                        case action:
                            break;
                        case musicalScore:
                            e.preventDefault();
                            dt.dropEffect = 'copy';
                            break;
                    }
                    break;
                case musicalScore:
                    switch (target) {
                        case tones:
                            break;
                        case action:
                            break;
                        case musicalScore:
                            e.preventDefault();
                            if (!ctrlKey) {
                                dt.dropEffect = 'move';
                            } else {
                                dt.dropEffect = 'copy';
                            }
                            break;
                    }
                    break;
            }
            dropEffect = dt.dropEffect;
        };
        target.addEventListener('dragover', dragEventHandler);
        const dragenterEventHandler = e => {
            if (doNotDrag) {
                return;
            }
            const {from = null} = dragInfo;
            const isButton =  e.target.tagName.toLowerCase() === 'button';
            const addClass = () => e.target.classList.add('droppable');
            switch (from) {
                case tones:
                    switch (target) {
                        case tones:
                            e.preventDefault(); // polyfill用
                            if (isButton) {
                                addClass();
                            }
                            break;
                        case action:
                            break;
                        case musicalScore:
                            e.preventDefault(); // polyfill用
                            if (isButton) {
                                addClass();
                            }
                            break;
                    }
                    break;
                case action:
                    switch (target) {
                        case tones:
                            break;
                        case action:
                            break;
                        case musicalScore:
                            e.preventDefault(); // polyfill用
                            if (isButton) {
                                addClass();
                            }
                            break;
                    }
                    break;
                case musicalScore:
                    switch (target) {
                        case tones:
                            break;
                        case action:
                            break;
                        case musicalScore:
                            e.preventDefault(); // polyfill用
                            if (isButton) {
                                addClass();
                            }
                            break;
                    }
                    break;
            }
        };
        target.addEventListener('dragenter', dragenterEventHandler);
        const dragleaveEventHandler = e => {
            if (doNotDrag) {
                return;
            }
            const {from = null} = dragInfo;
            const isButton =  e.target.tagName.toLowerCase() === 'button';
            const removeClass = () => e.target.classList.remove('droppable');
            switch (from) {
                case tones:
                    switch (target) {
                        case tones:
                            if (isButton) {
                                removeClass();
                            }
                            break;
                        case action:
                            break;
                        case musicalScore:
                            if (isButton) {
                                removeClass();
                            }
                            break;
                    }
                    break;
                case action:
                    switch (target) {
                        case tones:
                            break;
                        case action:
                            break;
                        case musicalScore:
                            if (isButton) {
                                removeClass();
                            }
                            break;
                    }
                    break;
                case musicalScore:
                    switch (target) {
                        case tones:
                            break;
                        case action:
                            break;
                        case musicalScore:
                            if (isButton) {
                                removeClass();
                            }
                            break;
                    }
                    break;
            }
        };
        target.addEventListener('dragleave', dragleaveEventHandler);
        target.addEventListener('drop', async e => {
            e.preventDefault();
            if (doNotDrag) {
                return;
            }
            if (e.dataTransfer.items?.length) { // ?はpolyfill用
                return;
            }
            e.dataTransfer.dropEffect = e.dataTransfer.dropEffect !== 'none' ? e.dataTransfer.dropEffect : dropEffect;
            const {from, item} = dragInfo;
            const ul = e.target.closest('#tones, #musical-score').querySelector('ul');
            const itemIndex = [...ul.children].indexOf(item.parentElement);
            const targetIndex = [...ul.children].indexOf(e.target.parentElement);
            const targetIsButton =  e.target.tagName.toLowerCase() === 'button';
            let newNode;
            switch (e.dataTransfer.dropEffect) {
                case 'copy':
                    const li = document.createElement('li')
                    const newItem = item.cloneNode(true);
                    if (target === tones) {
                        const noteClassName = [...item.classList].find(name => name.includes('note-'));
                        newItem.classList.replace(noteClassName, getNonExistNoteClassName());
                    } else if (from === action && 'otherAction' in newItem.dataset) {
                        await actionPromptSwitcher(newItem);
                    }
                    li.appendChild(newItem);
                    newNode = li;
                    break;
                case 'move':
                    newNode = item.parentElement;
                    break;
            }
            if (targetIsButton) {
                const position = e.dataTransfer.dropEffect === 'copy' || targetIndex < itemIndex ? 'beforebegin' : 'afterend';
                e.target.parentElement.insertAdjacentElement(position, newNode);
            } else {
                ul.appendChild(newNode);
            }
            lastTouchedButton = newNode.firstElementChild;
            if (target === musicalScore) {
                block.blocksDataUpdate();
                block.calcPoly();
                block.saveBlocksData();
                block.exportMml(mml);
                if ('tonePitch' in lastTouchedButton.dataset) {
                    lastTouchedButton.dataset.tonePitch = lastTouchedButton.dataset.tonePitch.replace(/[><]+/, '');
                    playMusicNote(lastTouchedButton);
                    lastTouchedButton.classList.add('bounce');
                }
            }
            switch (e.dataTransfer.dropEffect) {
                case 'copy':
                    history.pushState({
                        operation: 'copy',
                        toIndex: targetIndex,
                        newElem: newNode,
                        parent: ul
                    });
                    break;
                case 'move':
                    history.pushState({
                        operation: 'move',
                        fromIndex: itemIndex,
                        toIndex: targetIndex,
                        elem: newNode,
                        parent: ul
                    });
                    break;
            }
        });
        const dragendEventHandler = e => {
            [...document.getElementsByClassName('droppable')].forEach(elem => {
                elem.classList.remove('droppable');
            });
        };
        target.addEventListener('dragend', dragendEventHandler);
    });

    editor.addEventListener('animationend', e => {
        e.target.classList.remove('bounce');
        e.target.classList.remove('pop');
    });

    //---------------
    // Form Controls
    //---------------

    mmlForm.addEventListener('submit', async e => {
        e.preventDefault();
        const mmlArr = mml.getMmlArr();
        switch (e.submitter) {
            case mmlForm.add.btn:
                mmlForm.add.field.disabled = true;
                mmlForm.add.btn.textContent = '追加中...';
                const addMmlText = mmlForm.add.mmlText.value;
                mml.append(addMmlText);
                history.pushState({
                    operation: 'append',
                    index: mmlArr.length - 1,
                    mmlText: addMmlText
                });
                mmlArr.length && (mmlForm.add.field.disabled = false);
                mmlForm.add.btn.textContent = '追加';
                break;
            case mmlForm.del.btn:
                mmlForm.del.field.disabled = true;
                mmlForm.del.btn.textContent = '削除中...';
                const delIndex = Number(mmlForm.del.index.value);
                const delMmlText = mmlArr[delIndex];
                mml.delete(delIndex);
                history.pushState({
                    operation: 'delete',
                    index: delIndex,
                    mmlText: delMmlText
                });
                mmlArr.length && (mmlForm.del.field.disabled = false);
                mmlForm.del.btn.textContent = '削除';
                break;
            case mmlForm.rw.btn:
                mmlForm.rw.field.disabled = true;
                mmlForm.rw.btn.textContent = '書換中...';
                const rwIndex = Number(mmlForm.rw.index.value);
                const rwMmlText = mmlForm.rw.mmlText.value;
                const beforeRwMmlText = mmlArr[rwIndex];
                mml.rewrite(rwIndex, rwMmlText);
                history.pushState({
                    operation: 'rewrite',
                    index: rwIndex,
                    beforeMmlText: beforeRwMmlText,
                    afterMmlText: rwMmlText
                });
                mmlArr.length && (mmlForm.rw.field.disabled = false);
                mmlForm.rw.btn.textContent = '書換';
                break;
        }
    });

    //----------------
    // /Form Controls
    //----------------

    dialog.addEventListener('click', e => {
        if (e.target === dialog) {
            dialog.close();
        }
    });

    dialogForm.addEventListener('submit', e => {
        const submitTarget = dialogFormManager.submitTarget;
        const beforeChange = JSON.parse(JSON.stringify(submitTarget.dataset));
        switch (e.submitter.value) {
            case 'set-tone':
                const buttonClassName = submitTarget.className;
                document.querySelectorAll(`[class="${buttonClassName}"]`).forEach(elem => {
                    elem.ariaLabel = dialogForm.elements['tone-name'].value;
                    if (!elem.classList.contains('material-icons') || dialogForm.elements['tone-name'].value !== '無調整') {
                        elem.classList.remove('material-icons');
                        elem.textContent = dialogForm.elements['tone-name'].value;
                    }
                    elem.dataset.tone = dialogForm.elements['tone-def'].value;
                    document.querySelector('emoji-picker').classList.remove('expaned');
                });
                break;
            case 'set-tone-pitch':
                submitTarget.dataset.tonePitch = submitTarget.dataset.tonePitch.replace(/[0-9]+/, '') + dialogForm.elements['tone-pitch'].value;
                break;
            case 'set-tempo':
                submitTarget.dataset.tempo = 't' + dialogForm.elements['tempo'].value;
                break;
            case 'set-note-value':
                submitTarget.dataset.noteValue = 'l' + dialogForm.elements['note-value'].value;
                break;
            case 'set-rest':
                submitTarget.dataset.rest = 'r' + dialogForm.elements['rest'].value;
                break;
            case 'set-octave':
                submitTarget.dataset.octave = 'o' + dialogForm.elements['octave'].value;
                break;
            case 'set-velocity':
                submitTarget.dataset.velocity = '@v' + dialogForm.elements['velocity'].value;
                break;
            case 'set-note-shift':
                submitTarget.dataset.noteShift = '@ns' + dialogForm.elements['note-shift'].value;
                break;
            case 'set-detune':
                submitTarget.dataset.detune = '@d' + dialogForm.elements['detune'].value;
                break;
            case 'set-loop':
                submitTarget.dataset.loopStart = '/:' + dialogForm.elements['loop'].value;
                break;
            case 'set-using-poly':
                submitTarget.dataset.usingPoly = '#USING POLY ' + dialogForm.elements['using-poly'].value + ' force\n';
                break;
            case 'set-other-action':
                submitTarget.dataset.otherAction = dialogForm.elements['other-action'].value;
                submitTarget.textContent = submitTarget.dataset.otherAction;
                break;
        }
        const afterChange = JSON.parse(JSON.stringify(submitTarget.dataset));
        if (beforeChange !== afterChange) {
            history.pushState({
                operation: 'valueChange',
                target: submitTarget,
                beforeChange,
                afterChange
            });
        }
        dialogFormManager.resolve();
    });

    playBtn.addEventListener('click', () => {
        const isPlaying = flmml.isPlaying();
        if (!isPlaying) {
            flmml.play(mml.getMml());
            flmml.addEventListener('compilecomplete', playAnimationStart);
        } else {
            flmml.stop();
            block.stopRendering();
            flmml.removeEventListener('compilecomplete', playAnimationStart);
        }
        playBtn.innerHTML = !isPlaying ? stopHtml : playHtml;
    });

    clearBtn.addEventListener('click', () => {
        if (confirm('音色と追加したブロックを全て消去しますか？')) {
            history.pushState({
                operation: 'clear',
                tonesChildren: [...tones.querySelector('ul').children],
                musicalScoreChildren: [...musicalScore.querySelector('ul').children],
                lastTouchedButton
            });
            tones.querySelector('ul').textContent = '';
            musicalScore.querySelector('ul').textContent = '';
            lastTouchedButton = null;
            block.blocksDataUpdate();
            block.saveBlocksData();
            block.exportMml(mml);
        }
    });

    copyBtn.addEventListener('click', () => {
        const mmlText = mml.getMml();
        const textCache = copyBtn.innerHTML;
        copyBtn.disabled = true;
        navigator.clipboard.writeText(mmlText)
        .then(() => {
            copyBtn.disabled = true;
            copyBtn.innerHTML = createMIsHtml('content_copy') + 'コピーしました';
            setTimeout(() => {
                copyBtn.innerHTML = textCache;
                copyBtn.disabled = false;
            }, 1500);
        })
        .catch(e => alert('コピーできませんでした\n' + e));
    });

    saveBtn.addEventListener('click', () => {
        const mmlText = mml.getMml();
        const blob = new Blob([mmlText], {type: 'text/plain'});
        const link = document.createElement('a');
        link.download = 'Sequence' + '.mml';
        link.href = URL.createObjectURL(blob);
        link.click();
        URL.revokeObjectURL(link.href);
    });

    openBtn.addEventListener('click', () => {
        const inputFile = document.createElement('input');
        const fr = new FileReader();
        inputFile.type = 'file';
        inputFile.accept = '.mml,.flmml,.txt,text/plain'
        inputFile.click();
        inputFile.onchange = () => {
            fr.onload = () => {
                mml.setMml(fr.result);
                block.importMml(mml);
            };
            fr.readAsText(inputFile.files[0]);
        }
    });

    if (navigator.maxTouchPoints >= 2) {
        document.querySelector('.for-mobile').classList.add('show');
    }
    document.addEventListener('touchstart', e => {
        if (e.touches.length >= 2) {
            e.preventDefault();            
        }
    }, {passive: false});
    ctrlBtn.addEventListener('pointerdown', e => {
        if (e.isPrimary) {
            ctrlBtn.pressed = true;
        }
    });
    ctrlBtn.addEventListener('pointerup', e => {
        if (e.isPrimary) {
            ctrlBtn.pressed = false;
        }
    });
});