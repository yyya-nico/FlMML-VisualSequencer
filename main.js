import './style.scss'
import FlMMLWorkerLocation from './flmml-on-html5.worker.js?url'

import {FlMML} from "flmml-on-html5";
import { Picker } from 'emoji-picker-element';
import {htmlspecialchars, resetAnimation} from './utils';

const version = import.meta.env.VITE_APP_VER;

document.addEventListener('DOMContentLoaded', () => {
    const mmlForm = document.forms['mml-line'];
    mmlForm.add = {
        field: mmlForm.elements['add-mml'],
        mmlText: mmlForm.elements['add-mml-text'],
        btn: mmlForm.elements['add-button']
    };
    mmlForm.del = {
        field: mmlForm.elements['delete-mml'],
        index: mmlForm.elements['delete-mml-index'],
        btn: mmlForm.elements['delete-button']
    }
    mmlForm.rw = {
        field: mmlForm.elements['rewrite-mml'],
        index: mmlForm.elements['rewrite-mml-index'],
        mmlText: mmlForm.elements['rewrite-mml-text'],
        btn: mmlForm.elements['rewrite-button']
    }
    const editor = document.querySelector('.editor');
    const tones = document.getElementById('tones');
    const action = document.getElementById('action');
    const musicalScore = document.getElementById('musical-score');
    const dialog = document.getElementById('dialog');
    const dialogForm = document.forms['dialog-form'];
    dialogForm._title = dialogForm.querySelector('.form-title');
    dialogForm.inputs = dialogForm.querySelector('.inputs');
    dialogForm.buttons = dialogForm.querySelector('.buttons');
    const playBtn = document.getElementById('play');
    const warnOut = document.getElementById('warn-out');
    const mmlOut = document.getElementById('mml');
    const copyBtn = document.getElementById('copy');
    const saveBtn = document.getElementById('save');
    const openBtn = document.getElementById('open');

    class Mml {
        #generatorComment = `#COMMENT Generated by FlMML VisualSequencer ${version}`;
        #mml = [];
        #changeHandler = (arr, mmlText) => {};
        #errorHandler = (error, reason) => {};

        set onChange(fn) {
            this.#changeHandler = fn;
        }

        set onError(fn) {
            this.#errorHandler = fn;
        }

        setMmlArr(arr) {
            this.#mml = arr;
            this.#changeHandler(this.getMmlArr(), this.getMml());
        }

        setMml(str) {
            this.#mml = str.split('\n');
            const isGeneratedMmlText = this.#mml.at(-2) === '' && this.#mml.at(-1) === this.#generatorComment;
            if (isGeneratedMmlText) {
                this.#mml.splice(-2, 2);
            }
            this.#changeHandler(this.getMmlArr(), this.getMml());
        }

        getMmlArr() {
            return this.#mml;
        }

        getMml() {
            if (this.#mml.length) {
                return this.#mml.concat([
                    '',
                    this.#generatorComment
                ]).join('\n');
            } else {
                return '';
            }
        }

        insert(i, str) {
            const valid = Object.hasOwn(this.#mml, i) || i === 0;
            if (valid) {
                this.#mml.splice(i, 0, str);
                this.#changeHandler(this.getMmlArr(), this.getMml());
            } else {
                this.#errorHandler('範囲外の書き換え指定', `範囲${this.#mml.length - 1}までのところ、${i}`);
            }
        }

        append(str) {
            this.#mml.push(str);
            this.#changeHandler(this.getMmlArr(), this.getMml());
        }

        rewrite(i, str) {
            const valid = Object.hasOwn(this.#mml, i);
            if (valid) {
                this.#mml[i] = str;
                this.#changeHandler(this.getMmlArr(), this.getMml());
            } else {
                this.#errorHandler('範囲外の書き換え指定', `範囲${this.#mml.length - 1}までのところ、${i}`);
            }
        }

        delete(i, delCount = 1) {
            const valid = Object.hasOwn(this.#mml, i);
            if (valid && this.#mml.splice(i, delCount).length !== 0) {
                this.#changeHandler(this.getMmlArr(), this.getMml());
            } else {
                this.#errorHandler('無効な指定', `範囲${this.#mml.length - 1}までの中で${i}から${delCount}削除するのはできません`);
            }
        }
    }

    class Block {
        #blocksData = [];
        #rendTimeout = null;

        constructor(areaElem) {
            this.areaElem = areaElem;
        }

        blocksDataUpdate() {
            this.#blocksData = [...this.areaElem.getElementsByTagName('button')].map(elem => ({
                label: elem.ariaLabel,
                noteClassName: [...elem.classList].find(name => name.includes('note-')),
                tone: {
                    tone: elem.dataset.tone,
                    tonePitch: elem.dataset.tonePitch
                },
                tempo: elem.dataset.tempo,
                noteValue: elem.dataset.noteValue,
                rest: elem.dataset.rest,
                octave: elem.dataset.octave,
                velocity: elem.dataset.velocity,
                noteShift: elem.dataset.noteShift,
                detune: elem.dataset.detune,
                loopStart: elem.dataset.loopStart,
                loopBreak: elem.dataset.loopBreak,
                loopEnd: elem.dataset.loopEnd,
                usingPoly: elem.dataset.usingPoly,
                polyStartEnd: elem.dataset.polyStartEnd,
                otherAction: elem.dataset.otherAction,
                elem: elem
            }));
        }
        
        exportMml(mml) {
            mml.setMmlArr([]);
            let mmlText = '';
            this.#blocksData.forEach(block => {
                const {tone, tonePitch} = block.tone;
                mmlText += tonePitch || block.tempo || block.noteValue || block.rest
                    || block.octave || block.velocity || block.noteShift || block.detune
                    || block.loopStart || block.loopBreak || block.loopEnd || block.usingPoly
                    || block.polyStartEnd || block.otherAction || '';
            });
            mml.append(mmlText);
        }

        playRendering() {
            const data = this.#blocksData;
            let tempo = 120;
            let scoreNoteValue = 4;
            let skip = false;
            let i = 0;
            musicalScore.classList.add('no-op');
            const attachMotion = () => {
                const current = data[i];
                if (!current || i >= current.length) {
                    musicalScore.classList.remove('no-op');
                    return;
                } else if (current.tone.tonePitch) {
                    const currentNoteValue = Number(current.tone.tonePitch.replace(/[a-g]\+?/, '')) || scoreNoteValue;
                    resetAnimation(current.elem, 'bounce');
                    i++;
                    const nextSiblingIsPolyEnd = current.elem.parentElement.nextSibling?.firstElementChild.dataset.polyStartEnd === ']';
                    if (!skip || nextSiblingIsPolyEnd) {
                        this.#rendTimeout = setTimeout(attachMotion,
                            60 / tempo * 4 / currentNoteValue * 1000);
                    } else {
                        attachMotion();
                    }
                } else if (current.rest) {
                    const currentNoteValue = Number(current.rest.replace('r', '')) || scoreNoteValue;
                    resetAnimation(current.elem, 'pop');
                    i++;
                    this.#rendTimeout = setTimeout(attachMotion,
                        60 / tempo * 4 / currentNoteValue * 1000);
                } else {
                    current.tempo && (tempo = Number(current.tempo.replace('t', '')) || tempo);
                    current.noteValue && (scoreNoteValue = Number(current.noteValue.replace('l', '')) || scoreNoteValue);
                    current.polyStartEnd && (skip = current.polyStartEnd === '[');
                    resetAnimation(current.elem, 'pop');
                    i++;
                    attachMotion();
                }
                current.elem.classList.add('done');
            }
            attachMotion();
        }

        stopRendering() {
            musicalScore.classList.remove('no-op');
            this.#blocksData.forEach(block => {
                block.elem.classList.remove('done');
            });
            clearTimeout(this.#rendTimeout);
        }

        calcPoly() {
            const polyBlocksData = this.#blocksData.filter(block => block.polyStartEnd);
            polyBlocksData.forEach((block, i) => {
                if (i % 2 === 0) {
                    block.elem.dataset.polyStartEnd = '[';
                    block.elem.textContent = '[';
                } else {
                    block.elem.dataset.polyStartEnd = ']';
                    block.elem.textContent = ']';
                }
            });
            this.blocksDataUpdate();
        }
    }

    class History {
        #histArr = [[],[]];
        #maxArrLength = 70;
        #popstateHandler = obj => {};

        set onPopstate(fn) {
            this.#popstateHandler = fn;
        }
        
        pushState(obj) {
            this.#histArr[0].push(obj);
            if (this.#histArr[0].length > this.#maxArrLength) {
                this.#histArr[0].shift();
            }
            this.#histArr[1].length = 0;
        }

        undo() {
            const data = this.#histArr[0].pop();
            this.#popstateHandler({
                reason: 'undo',
                data
            });
            data && this.#histArr[1].unshift(data);
        }

        redo() {
            const data = this.#histArr[1].shift();
            this.#popstateHandler({
                reason: 'redo',
                data
            });
            data && this.#histArr[0].push(data);
        }

        clear() {
            this.#histArr[0].length = 0;
            this.#histArr[1].length = 0;
        }
    }

    class DialogFormManager {
        #dialogDefinitions = {
            tone: {
                title: '音色設定',
                inputs: [
                    {
                        label: '名前',
                        type: 'text',
                        name: 'tone-name'
                    },
                    {
                        label: '音の定義',
                        type: 'text',
                        name: 'tone-def',
                        autofocus: ''
                    },
                ],
                buttons: [
                    {
                        class: 'primaly',
                        value: 'set-tone',
                        textContent: '確定'
                    }
                ]
            },
            tonePitch: {
                title: '音価設定',
                inputs: [
                    {
                        label: '音価(音の長さ)',
                        type: 'number',
                        name: 'tone-pitch'
                    }
                ],
                buttons: [
                    {
                        class: 'primaly',
                        value: 'set-tone-pitch',
                        textContent: '確定'
                    }
                ]
            },
            tempo: {
                title: 'テンポ設定',
                inputs: [
                    {
                        label: 'テンポ指定(BPM)',
                        type: 'number',
                        name: 'tempo'
                    }
                ],
                buttons: [
                    {
                        class: 'primaly',
                        value: 'set-tempo',
                        textContent: '確定'
                    }
                ]
            },
            noteValue: {
                title: '音価設定',
                inputs: [
                    {
                        label: '音価(音の長さ)',
                        type: 'number',
                        name: 'note-value'
                    }
                ],
                buttons: [
                    {
                        class: 'primaly',
                        value: 'set-note-value',
                        textContent: '確定'
                    }
                ]
            },
            rest: {
                title: '休符設定',
                inputs: [
                    {
                        label: '休符の長さ',
                        type: 'number',
                        name: 'rest'
                    }
                ],
                buttons: [
                    {
                        class: 'primaly',
                        value: 'set-rest',
                        textContent: '確定'
                    }
                ]
            },
            octave: {
                title: 'オクターブ設定',
                inputs: [
                    {
                        label: 'オクターブ位置',
                        type: 'number',
                        name: 'octave'
                    }
                ],
                buttons: [
                    {
                        class: 'primaly',
                        value: 'set-octave',
                        textContent: '確定'
                    }
                ]
            },
            velocity: {
                title: '音量設定',
                inputs: [
                    {
                        label: '音量',
                        type: 'number',
                        name: 'velocity'
                    }
                ],
                buttons: [
                    {
                        class: 'primaly',
                        value: 'set-velocity',
                        textContent: '確定'
                    }
                ]
            },
            noteShift: {
                title: 'ノートシフト設定',
                inputs: [
                    {
                        label: 'シフト量',
                        type: 'number',
                        name: 'note-shift'
                    }
                ],
                buttons: [
                    {
                        class: 'primaly',
                        value: 'set-note-shift',
                        textContent: '確定'
                    }
                ]
            },
            detune: {
                title: 'デチューン設定',
                inputs: [
                    {
                        label: 'デチューン量',
                        type: 'number',
                        name: 'detune'
                    }
                ],
                buttons: [
                    {
                        class: 'primaly',
                        value: 'set-detune',
                        textContent: '確定'
                    }
                ]
            },
            loop: {
                title: 'ループ設定',
                inputs: [
                    {
                        label: 'ループ回数',
                        type: 'number',
                        name: 'loop'
                    }
                ],
                buttons: [
                    {
                        class: 'primaly',
                        value: 'set-loop',
                        textContent: '確定'
                    }
                ]
            },
            usingPoly: {
                title: '和音設定',
                inputs: [
                    {
                        label: '和音重ね数',
                        type: 'number',
                        name: 'using-poly'
                    }
                ],
                buttons: [
                    {
                        class: 'primaly',
                        value: 'set-using-poly',
                        textContent: '確定'
                    }
                ]
            },
            otherAction: {
                title: 'その他の作用設定',
                inputs: [
                    {
                        label: '任意のMML',
                        type: 'text',
                        name: 'other-action'
                    }
                ],
                buttons: [
                    {
                        class: 'primaly',
                        value: 'set-other-action',
                        textContent: '確定'
                    }
                ]
            }
        }
        #createElems = (type) => {
            const def = this.#dialogDefinitions[type];
            Object.keys(def).forEach(key => {
                switch (key) {
                    case 'title':
                        dialogForm._title.textContent = def.title;
                        break;
                    case 'inputs':
                        def.inputs.forEach(inputDef => {
                            const input = document.createElement('input');
                            let appendElem = input;
                            Object.entries(inputDef).forEach(entry => {
                                if (entry[0] === 'label') {
                                    const label = document.createElement('label');
                                    label.innerHTML = entry[1];
                                    label.appendChild(input);
                                    appendElem = label;
                                } else if (entry[0] === 'select') {
                                    const select = document.createElement('select');
                                    const selectOptionsDef = entry[1];
                                    Object.entry(selectOptionsDef).forEach(entry => {
                                        const option = document.createElement('option');
                                        option.value = entry[0];
                                        option.textContent = entry[1];
                                        select.appendChild(option);
                                    });
                                    appendElem = select;
                                } else {
                                    input.setAttribute(entry[0], entry[1]);
                                }
                            });
                            dialogForm.inputs.appendChild(appendElem);
                        });
                        break;
                    case 'buttons':
                        def.buttons.forEach(buttonDef => {
                            const button = document.createElement('button');
                            Object.entries(buttonDef).forEach(entry => {
                                if (entry[0] === 'textContent') {
                                    button.textContent = entry[1];
                                } else {
                                    button.setAttribute(entry[0], entry[1]);
                                }
                            });
                            dialogForm.buttons.appendChild(button);
                        });
                        break;
                }
            });
        }

        #set = (type, initVals) => {
            dialogForm._title.textContent = '';
            dialogForm.inputs.textContent = '';
            dialogForm.buttons.textContent = '';
            this.#createElems(type);
            for (const [name, value] of Object.entries(initVals)) {
                if (name === 'run') {
                    value();
                } else {
                    dialogForm.elements[name].value = value;
                }
            }
            this.type = type;
        }

        constructor() {
            this.type = null;
            this.submitTarget = null;
            this.resolve = null;
        }

        async prompt(type, initVals, submitTarget) {
            this.#set(type, initVals);
            this.submitTarget = submitTarget;
            dialog.showModal();
            return new Promise(resolve => this.resolve = resolve);
        }
    }

    FlMML.prepare(`.editor`);
    const flmml = new FlMML({workerURL: FlMMLWorkerLocation});
    const mml = new Mml();
    const block = new Block(musicalScore);
    const history = new History();
    const dialogFormManager = new DialogFormManager();
    const picker = new Picker({
        locale: 'ja'
    });

    const createMIsHtml = name => `<span class="material-icons">${name}</span>`;
    const playHtml = createMIsHtml('play_arrow') + '再生';
    const stopHtml = createMIsHtml('stop') + '停止';

    const playAnimationStart = () => {
        block.playRendering();
    };
    const compileHandler = () => {
        warnOut.innerHTML = flmml.getWarnings().replaceAll('\n','<br>');
    };
    flmml.addEventListener('compilecomplete', compileHandler);
    const completeHandler = () => {
        playBtn.innerHTML = playHtml;
        block.stopRendering();
        flmml.removeEventListener('compilecomplete', playAnimationStart);
    };
    flmml.addEventListener('complete', completeHandler);

    mml.onChange = (arr, mmlText) => {
        mmlOut.innerHTML = mmlText ? `<pre><code>${htmlspecialchars(mmlText).replaceAll('\n','<br>')}</code></pre>` : '(なし)';
        const mmlIsExist = Boolean(arr.length);
        [mmlForm.del.field, mmlForm.rw.field, copyBtn, saveBtn].forEach(elem => {
            elem.disabled = !mmlIsExist;
        });
        if (mmlIsExist) {
            mmlForm.del.index.max = arr.length - 1;
            mmlForm.rw.index.max = arr.length - 1;
            mmlForm.del.index.value > mmlForm.del.index.max && (mmlForm.del.index.value = mmlForm.del.index.max);
            mmlForm.rw.index.value > mmlForm.rw.index.max && (mmlForm.rw.index.value = mmlForm.rw.index.max);
            localStorage.setItem('mmlArray', JSON.stringify(arr));
        } else {
            localStorage.removeItem('mmlArray');
        }
    };
    mml.onError = (error, reason) => {
        alert(error + '\n' + reason);
    };
    const savedMmlArr = JSON.parse(localStorage.getItem('mmlArray'));
    if (savedMmlArr) {
        mml.setMmlArr(savedMmlArr);
    }

    history.onPopstate = obj => {
        const data = obj.data;
        switch (obj.reason) {
            case 'undo':
                switch (data?.operation) { //元に戻す操作集
                    case 'append':
                        mml.delete(data.index);
                        break;
                    case 'delete':
                        mml.insert(data.index, data.mmlText);
                        break;
                    case 'rewrite':
                        mml.rewrite(data.index, data.beforeMmlText);
                        break;
                }
                break;
            case 'redo':
                switch (data?.operation) { //やり直し操作集
                    case 'append':
                        mml.append(data.mmlText);
                        break;
                    case 'delete':
                        mml.delete(data.index);
                        break;
                    case 'rewrite':
                        mml.rewrite(data.index, data.afterMmlText);
                        break;
                }
                break;
        }
    };

    const getNonExistNoteClassName = () => {
        const noteClassNames = [...tones.getElementsByTagName('button')].map(elem => [...elem.classList].find(name => name.includes('note-')));
        for (let index = 1; ; index++) {
            if (!noteClassNames.includes('note-' + index)) {
                return 'note-' + index;
            }
        }
    };

    document.addEventListener('keydown', e => {
        switch (e.key.toLowerCase()) {
            case ' ':
                if (document.activeElement.tagName.toLowerCase() !== 'input') { // contentEditableのことは考えていない
                    e.preventDefault();
                    playBtn.click();
                }
                break;
            case 'z':
                e.ctrlKey && history.undo();
                break;
            case 'y':
                e.ctrlKey && history.redo();
                break;
        }
    });

    const actionPromptSwitcher = async item => {
        if ('tempo' in item.dataset) {
            await dialogFormManager.prompt('tempo', {
                'tempo': item.dataset.tempo.replace('t', '')
            }, item);
        } else if ('noteValue' in item.dataset) {
            await dialogFormManager.prompt('noteValue', {
                'note-value': item.dataset.noteValue.replace('l', '')
            }, item);
        } else if ('rest' in item.dataset) {
            await dialogFormManager.prompt('rest', {
                'rest': item.dataset.rest.replace('r', '')
            }, item);
        } else if ('octave' in item.dataset) {
            await dialogFormManager.prompt('octave', {
                'octave': item.dataset.octave.replace('o', '')
            }, item);
        } else if ('velocity' in item.dataset) {
            await dialogFormManager.prompt('velocity', {
                'velocity': item.dataset.velocity.replace('@v', '')
            }, item);
        } else if ('noteShift' in item.dataset) {
            await dialogFormManager.prompt('noteShift', {
                'note-shift': item.dataset.noteShift.replace('@ns', '')
            }, item);
        } else if ('detune' in item.dataset) {
            await dialogFormManager.prompt('detune', {
                'detune': item.dataset.detune.replace('@d', '')
            }, item);
        } else if ('loopEnd' in item.dataset) {
            const findLoopStartElem = () => {
                let findTemp = item.parentElement;
                while (findTemp && !('loopStart' in findTemp.firstElementChild.dataset)) {
                    findTemp = findTemp.previousElementSibling;
                };
                return findTemp?.firstElementChild || null;
            };
            let loopStartElem = findLoopStartElem();
            const loopStartCount = musicalScore.getElementsByClassName('loop-start').length;
            const loopEndCount = musicalScore.getElementsByClassName('loop-end').length;
            const enoughLoopEnds = loopStartCount === loopEndCount;
            const parentMusicalScore = item.closest('#musical-score');
            if (!loopStartElem || enoughLoopEnds && !parentMusicalScore) {
                const ul = musicalScore.querySelector('ul');
                const li = document.createElement('li');
                const baseItem = action.querySelector('.loop-start');
                const newItem = baseItem.cloneNode(true);
                li.appendChild(newItem);
                ul.appendChild(li);
                loopStartElem = newItem;
            }
            await dialogFormManager.prompt('loop', {
                'loop': loopStartElem.dataset.loopStart.replace('/:', '')
            }, loopStartElem);
        } else if ('usingPoly' in item.dataset) {
            await dialogFormManager.prompt('usingPoly', {
                'using-poly': item.dataset.usingPoly.replace('#USING POLY ', '').replace('\n', '')
            }, item);
        } else if ('otherAction' in item.dataset) {
            await dialogFormManager.prompt('otherAction', {
                'other-action': item.dataset.otherAction
            }, item);
        }
    };
    let lastTouchedButton = tones.querySelector('button');
    editor.addEventListener('click', async e => {
        const is = id => Boolean(e.target.closest('#' + id));
        const isButton =  e.target.tagName.toLowerCase() === 'button';
        if (is('tones')) {
            if (isButton) {
                lastTouchedButton = e.target;
                await dialogFormManager.prompt('tone', {
                    'tone-name': e.target.ariaLabel,
                    'tone-def': e.target.dataset.tone,
                    'run': () => {
                        const toneName = dialogForm.elements['tone-name'];
                        toneName.insertAdjacentElement('afterend', document.createElement('emoji-picker'));
                        document.querySelector('emoji-picker')
                            .addEventListener('emoji-click', e => toneName.value = e.detail.unicode);
                    }
                }, e.target);
                flmml.play(e.target.dataset.tone + e.target.dataset.tonePitch);
            } else {
                const ul = tones.querySelector('ul');
                const li = document.createElement('li');
                const nonExistClassName = getNonExistNoteClassName();
                const toneButton = `<button class="material-icons plain ${nonExistClassName}" aria-label="無調整" draggable="true" data-tone="" data-tone-pitch="c">music_note</button>`;
                li.innerHTML = toneButton;
                const newItem = li.firstElementChild;
                ul.appendChild(li);
                lastTouchedButton = newItem;
                flmml.play(newItem.dataset.tone + newItem.dataset.tonePitch);
            }
        } else if (is('action')) {
            if (isButton) {
                if (!('rest' in e.target.dataset)) {
                    await actionPromptSwitcher(e.target);
                }
                const ul = musicalScore.querySelector('ul');
                const li = document.createElement('li');
                const newItem = e.target.cloneNode(true);
                li.appendChild(newItem);
                ul.appendChild(li);
                lastTouchedButton = newItem;
                block.blocksDataUpdate();
                block.calcPoly();
                block.exportMml(mml);
            }
        } else if (is('musical-score')) {
            if (musicalScore.classList.contains('no-op')) {
                return;
            } else if (isButton) {
                if ('tone' in e.target.dataset) {
                    flmml.play(e.target.dataset.tone + e.target.dataset.tonePitch);
                    resetAnimation(e.target, 'bounce');
                    e.ctrlKey && await dialogFormManager.prompt('tonePitch', {
                        'tone-pitch': e.target.dataset.tonePitch.replace(/[a-f]\+?/, '')
                    }, e.target);
                    flmml.play(e.target.dataset.tone + e.target.dataset.tonePitch);
                } else {
                    await actionPromptSwitcher(e.target);
                }
                lastTouchedButton = e.target;
                block.blocksDataUpdate();
                block.exportMml(mml);
            } else {
                if (lastTouchedButton) {
                    const ul = musicalScore.querySelector('ul');
                    const li = document.createElement('li');
                    const newItem = lastTouchedButton.cloneNode(true);
                    li.appendChild(newItem);
                    ul.appendChild(li);
                    lastTouchedButton = newItem;
                    block.blocksDataUpdate();
                    block.calcPoly();
                    block.exportMml(mml);
                    if ('tonePitch' in newItem.dataset) {
                        flmml.play(newItem.dataset.tone + newItem.dataset.tonePitch);
                        newItem.classList.add('bounce');
                    }
                }
            }
        }
    });

    editor.addEventListener('contextmenu', e => {
        const parent = target => target.closest('#tones, #musical-score');
        const is = id => Boolean(e.target.closest('#' + id));
        const isButton =  e.target.tagName.toLowerCase() === 'button';
        if (parent(e.target)?.classList.contains('no-op')) {
            return;
        } else if (parent(e.target)) {
            const target = isButton ? e.target : lastTouchedButton;
            if (!target || parent(target) !== parent(e.target)) {
                return;
            }
            e.preventDefault();
            const removeTarget = target.parentElement;
            const buttonClassName = target.className;
            lastTouchedButton = removeTarget.previousElementSibling?.firstElementChild
                                || removeTarget.nextElementSibling?.firstElementChild
                                || null;
            removeTarget.remove();
            if (is('tones')) {
                musicalScore.querySelectorAll(`[class="${buttonClassName}"]`).forEach(elem => {
                    elem.parentElement.remove();
                });
            }
            block.blocksDataUpdate();
            block.calcPoly();
            block.exportMml(mml);
        }
    });

    editor.addEventListener('wheel', e => {
        const is = id => Boolean(e.target.closest('#' + id));
        const isButton =  e.target.tagName.toLowerCase() === 'button';
        const isPositive = e.deltaY < 0;
        let target = isButton ? e.target : lastTouchedButton?.closest('#musical-score') && lastTouchedButton;
        if (!target) {
            return;            
        } else if (is('musical-score')) {
            if (musicalScore.classList.contains('no-op')) {
                return;
            }
            e.preventDefault();
            if (target) {
                if (!e.ctrlKey && 'tone' in target.dataset) {
                    const pitches = ['c','c+','d','d+','e','f','f+','g','g+','a','a+','b'];
                    const octave = ['>', '<'];
                    const currentPitch = target.dataset.tonePitch;
                    const currentPitchIndex = pitches.findIndex(pitch => currentPitch.replace(/[><0-9]+/g, '') === pitch);
                    const countStr = str => (currentPitch.match(new RegExp(str, 'g')) || []).length;
                    const octaveCount = [
                        countStr(octave[0]),
                        countStr(octave[1])
                    ]
                    const octaveStr = octave[0].repeat(octaveCount[0]) + octave[1].repeat(octaveCount[1]);
                    const noteValue = (currentPitch.match(/[0-9]+/) || [''])[0];
                    if (isPositive) { // Up
                        if (currentPitchIndex === pitches.length - 1) {
                            if (octaveCount[0]) {
                                target.dataset.tonePitch = octaveStr.substring(1) + pitches.at(0) + noteValue;
                            } else {
                                target.dataset.tonePitch = octaveStr + octave[1] + pitches.at(0) + noteValue;
                            }
                        } else {
                            target.dataset.tonePitch = octaveStr + pitches[currentPitchIndex + 1] + noteValue;
                        }
                    } else { // Down
                        if (currentPitchIndex === 0) {
                            if (octaveCount[1]) {
                                target.dataset.tonePitch = octaveStr.substring(1) + pitches.at(-1) + noteValue;
                            } else {
                                target.dataset.tonePitch = octaveStr + octave[0] + pitches.at(-1) + noteValue;
                            }
                        } else {
                            target.dataset.tonePitch = octaveStr + pitches[currentPitchIndex - 1] + noteValue;
                        }
                    }
                    flmml.play(target.dataset.tone + target.dataset.tonePitch);
                } else {
                    const increaseBase = isPositive ? 1 : -1;
                    const neverMinus = current => current + increaseBase < 0 ? 0 : increaseBase;
                    if (e.ctrlKey && 'tonePitch' in target.dataset) {
                        const noteValue = Number(target.dataset.tonePitch.replace(/[a-f]\+?/, ''));
                        const increase = neverMinus(noteValue);
                        target.dataset.tonePitch = target.dataset.tonePitch.replace(/[0-9]+/, '') + (noteValue + increase);
                        flmml.play(target.dataset.tone + target.dataset.tonePitch);
                    } else if ('tempo' in target.dataset) {
                        const tempo = Number(target.dataset.tempo.replace('t', ''));
                        const increase = neverMinus(tempo);
                        target.dataset.tempo = 't' + (tempo + increase * 10);
                    } else if ('noteValue' in target.dataset) {
                        const noteValue = Number(target.dataset.noteValue.replace('l', ''));
                        const increase = neverMinus(noteValue);
                        target.dataset.noteValue = 'l' + (noteValue + increase);
                    } else if ('rest' in target.dataset) {
                        const rest = Number(target.dataset.rest.replace('r', ''));
                        const increase = neverMinus(rest);
                        target.dataset.rest = 'r' + (rest + increase);
                    } else if ('octave' in target.dataset) {
                        const octave = Number(target.dataset.octave.replace('o', ''));
                        const increase = neverMinus(octave);
                        target.dataset.octave = 'o' + (octave + increase);
                    } else if ('velocity' in target.dataset) {
                        const velocity = Number(target.dataset.velocity.replace('@v', ''));
                        const increase = neverMinus(velocity);
                        target.dataset.velocity = '@v' + (velocity + increase);
                    } else if ('noteShift' in target.dataset) {
                        const noteShift = Number(target.dataset.noteShift.replace('@ns', ''));
                        const increase = neverMinus(noteShift);
                        target.dataset.noteShift = '@ns' + (noteShift + increase);
                    } else if ('detune' in target.dataset) {
                        const detune = Number(target.dataset.detune.replace('@d', ''));
                        const increase = neverMinus(detune);
                        target.dataset.detune = '@d' + (detune + increase);
                    } else if ('loopEnd' in target.dataset) {
                        const findLoopStartElem = () => {
                            let findTemp = musicalScore.querySelector('li:last-child');
                            while (findTemp && !('loopStart' in findTemp.firstElementChild.dataset)) {
                                findTemp = findTemp.previousElementSibling;
                            };
                            return findTemp?.firstElementChild || null;
                        };
                        let loopStartElem = findLoopStartElem();
                        const loopStartCount = musicalScore.getElementsByClassName('loop-start').length;
                        const loopEndCount = musicalScore.getElementsByClassName('loop-end').length;
                        const enoughLoopEnds = loopStartCount === loopEndCount;
                        if (!loopStartElem || enoughLoopEnds && !is('musical-score')) {
                            const ul = musicalScore.querySelector('ul');
                            const li = document.createElement('li');
                            const baseItem = action.querySelector('.loop-start');
                            const newItem = baseItem.cloneNode(true);
                            li.appendChild(newItem);
                            ul.appendChild(li);
                            loopStartElem = newItem;
                        }
                        const loop = Number(loopStartElem.dataset.loopStart.replace('/:', ''));
                        const increase = neverMinus(loop);
                        loopStartElem.dataset.loopStart = '/:' + (loop + increase);
                    } else if ('usingPoly' in target.dataset) {
                        const usingPoly = Number(target.dataset.usingPoly.replace('#USING POLY ', '').replace('\n', ''));
                        const increase = neverMinus(usingPoly);
                        target.dataset.usingPoly = '#USING POLY ' + (usingPoly + increase) + '\n';
                    }
                }
            }
            lastTouchedButton = target;
            block.blocksDataUpdate();
            block.exportMml(mml);
        }
    });

    let dragInfo = null;
    editor.addEventListener('dragstart', e => {
        const editorSectionElem = e.target.nodeType === 1/* ELEMENT */ && e.target.closest('#tones, #action, #musical-score');
        dragInfo = {
            from: editorSectionElem,
            item: e.target
        };
        e.dataTransfer.effectAllowed = 'copyMove';
    });
    let dropEffect = null;
    [tones, action, musicalScore].forEach(target => {
        const dragEventHandler = e => {
            const {from} = dragInfo;
            const dt = e.dataTransfer;
            switch (from) {
                case tones:
                    switch (target) {
                        case tones:
                            e.preventDefault();
                            if (!e.ctrlKey) {
                                dt.dropEffect = 'move';
                            } else {
                                dt.dropEffect = 'copy';
                            }
                            break;
                        case action:
                            break;
                        case musicalScore:
                            e.preventDefault();
                            dt.dropEffect = 'copy';
                            break;
                    }
                    break;
                case action:
                    switch (target) {
                        case tones:
                            break;
                        case action:
                            break;
                        case musicalScore:
                            e.preventDefault();
                            dt.dropEffect = 'copy';
                            break;
                    }
                    break;
                case musicalScore:
                    switch (target) {
                        case tones:
                            break;
                        case action:
                            break;
                        case musicalScore:
                            e.preventDefault();
                            if (!e.ctrlKey) {
                                dt.dropEffect = 'move';
                            } else {
                                dt.dropEffect = 'copy';
                            }
                            break;
                    }
                    break;
            }
            dropEffect = dt.dropEffect;
        };
        target.addEventListener('dragover', dragEventHandler);
        const dragenterEventHandler = e => {
            const {from} = dragInfo;
            const isButton =  e.target.tagName.toLowerCase() === 'button';
            const addClass = () => e.target.classList.add('droppable');
            switch (from) {
                case tones:
                    switch (target) {
                        case tones:
                            if (isButton) {
                                addClass();                                
                            }
                            break;
                        case action:
                            break;
                        case musicalScore:
                            if (isButton) {
                                addClass();                                
                            }
                            break;
                    }
                    break;
                case action:
                    switch (target) {
                        case tones:
                            break;
                        case action:
                            break;
                        case musicalScore:
                            if (isButton) {
                                addClass();                                
                            }
                            break;
                    }
                    break;
                case musicalScore:
                    switch (target) {
                        case tones:
                            break;
                        case action:
                            break;
                        case musicalScore:
                            if (isButton) {
                                addClass();                                
                            }
                            break;
                    }
                    break;
            }
        };
        target.addEventListener('dragenter', dragenterEventHandler);
        const dragleaveEventHandler = e => {
            const {from} = dragInfo;
            const isButton =  e.target.tagName.toLowerCase() === 'button';
            const removeClass = () => e.target.classList.remove('droppable');
            switch (from) {
                case tones:
                    switch (target) {
                        case tones:
                            if (isButton) {
                                removeClass();                                
                            }
                            break;
                        case action:
                            break;
                        case musicalScore:
                            if (isButton) {
                                removeClass();                                
                            }
                            break;
                    }
                    break;
                case action:
                    switch (target) {
                        case tones:
                            break;
                        case action:
                            break;
                        case musicalScore:
                            if (isButton) {
                                removeClass();                                
                            }
                            break;
                    }
                    break;
                case musicalScore:
                    switch (target) {
                        case tones:
                            break;
                        case action:
                            break;
                        case musicalScore:
                            if (isButton) {
                                removeClass();                                
                            }
                            break;
                    }
                    break;
            }
        };
        target.addEventListener('dragleave', dragleaveEventHandler);
        target.addEventListener('drop', async e => {
            e.preventDefault();
            e.dataTransfer.dropEffect = e.dataTransfer.dropEffect !== 'none' ? e.dataTransfer.dropEffect : dropEffect;
            const {from, item} = dragInfo;
            const ul = e.target.closest('#tones, #musical-score').querySelector('ul');
            const targetIsButton =  e.target.tagName.toLowerCase() === 'button';
            let newNode;
            switch (e.dataTransfer.dropEffect) {
                case 'copy':
                    const li = document.createElement('li')
                    const newItem = item.cloneNode(true);
                    if (target === tones) {
                        const noteClassName = [...item.classList].find(name => name.includes('note-'));
                        newItem.classList.replace(noteClassName, getNonExistNoteClassName());
                    } else if (from === action && !('rest' in newItem.dataset)) {
                        await actionPromptSwitcher(newItem);
                    }
                    li.appendChild(newItem);
                    newNode = li;
                    break;
                case 'move':
                    newNode = item.parentElement;
                    break;
            }
            if (targetIsButton) {
                const itemIndex = [...ul.children].indexOf(item.parentElement);
                const targetIndex = [...ul.children].indexOf(e.target.parentElement);
                const position = targetIndex < itemIndex || e.dataTransfer.dropEffect === 'copy' ? 'beforebegin' : 'afterend';
                e.target.parentElement.insertAdjacentElement(position, newNode);
            } else {
                ul.appendChild(newNode);
            }
            lastTouchedButton = newNode.firstElementChild;
            if (target === musicalScore) {
                block.blocksDataUpdate();
                block.calcPoly();
                block.exportMml(mml);
                if ('tonePitch' in lastTouchedButton.dataset) {
                    flmml.play(lastTouchedButton.dataset.tone + lastTouchedButton.dataset.tonePitch);
                    lastTouchedButton.classList.add('bounce');
                }
            }
        });
        const dragendEventHandler = e => {
            [...document.getElementsByClassName('droppable')].forEach(elem => {
                elem.classList.remove('droppable');
            });
        };
        target.addEventListener('dragend', dragendEventHandler);
    });

    editor.addEventListener('animationend', e => {
        e.target.classList.remove('bounce');
        e.target.classList.remove('pop');
    });

    //---------------
    // Form Controls
    //---------------

    mmlForm.addEventListener('submit', async e => {
        e.preventDefault();
        const mmlArr = mml.getMmlArr();
        switch (e.submitter) {
            case mmlForm.add.btn:
                mmlForm.add.field.disabled = true;
                mmlForm.add.btn.textContent = '追加中...';
                const addMmlText = mmlForm.add.mmlText.value;
                mml.append(addMmlText);
                history.pushState({
                    operation: 'append',
                    index: mmlArr.length - 1,
                    mmlText: addMmlText
                });
                mmlArr.length && (mmlForm.add.field.disabled = false);
                mmlForm.add.btn.textContent = '追加';
                break;
            case mmlForm.del.btn:
                mmlForm.del.field.disabled = true;
                mmlForm.del.btn.textContent = '削除中...';
                const delIndex = Number(mmlForm.del.index.value);
                const delMmlText = mmlArr[delIndex];
                mml.delete(delIndex);
                history.pushState({
                    operation: 'delete',
                    index: delIndex,
                    mmlText: delMmlText
                });
                mmlArr.length && (mmlForm.del.field.disabled = false);
                mmlForm.del.btn.textContent = '削除';
                break;
            case mmlForm.rw.btn:
                mmlForm.rw.field.disabled = true;
                mmlForm.rw.btn.textContent = '書換中...';
                const rwIndex = Number(mmlForm.rw.index.value);
                const rwMmlText = mmlForm.rw.mmlText.value;
                const beforeRwMmlText = mmlArr[rwIndex];
                mml.rewrite(rwIndex, rwMmlText);
                history.pushState({
                    operation: 'rewrite',
                    index: rwIndex,
                    beforeMmlText: beforeRwMmlText,
                    afterMmlText: rwMmlText
                });
                mmlArr.length && (mmlForm.rw.field.disabled = false);
                mmlForm.rw.btn.textContent = '書換';
                break;
        }
    });

    //----------------
    // /Form Controls
    //----------------

    dialog.addEventListener('click', e => {
        if (e.target === dialog) {
            dialog.close();
        }
    });

    dialogForm.addEventListener('submit', e => {
        const submitTarget = dialogFormManager.submitTarget;
        switch (e.submitter.value) {
            case 'set-tone':
                const buttonClassName = submitTarget.className;
                document.querySelectorAll(`[class="${buttonClassName}"]`).forEach(elem => {
                    elem.ariaLabel = dialogForm.elements['tone-name'].value;
                    elem.classList.remove('material-icons');
                    elem.textContent = dialogForm.elements['tone-name'].value;                    
                    elem.dataset.tone = dialogForm.elements['tone-def'].value;
                });
                break;
            case 'set-tone-pitch':
                submitTarget.dataset.tonePitch = submitTarget.dataset.tonePitch.replace(/[0-9]+/, '') + dialogForm.elements['tone-pitch'].value;
                break;
            case 'set-tempo':
                submitTarget.dataset.tempo = 't' + dialogForm.elements['tempo'].value;
                break;
            case 'set-note-value':
                submitTarget.dataset.noteValue = 'l' + dialogForm.elements['note-value'].value;
                break;
            case 'set-rest':
                submitTarget.dataset.rest = 'r' + dialogForm.elements['rest'].value;
                break;
            case 'set-octave':
                submitTarget.dataset.octave = 'o' + dialogForm.elements['octave'].value;
                break;
            case 'set-velocity':
                submitTarget.dataset.velocity = '@v' + dialogForm.elements['velocity'].value;
                break;
            case 'set-note-shift':
                submitTarget.dataset.noteShift = '@ns' + dialogForm.elements['note-shift'].value;
                break;
            case 'set-detune':
                submitTarget.dataset.detune = '@d' + dialogForm.elements['detune'].value;
                break;
            case 'set-loop':
                submitTarget.dataset.loopStart = '/:' + dialogForm.elements['loop'].value;
                break;
            case 'set-using-poly':
                submitTarget.dataset.usingPoly = '#USING POLY ' + dialogForm.elements['using-poly'].value + '\n';
                break;
            case 'set-other-action':
                submitTarget.dataset.otherAction = dialogForm.elements['other-action'].value;
                submitTarget.textContent = submitTarget.dataset.otherAction;
                break;
        }
        dialogFormManager.resolve();
    });

    playBtn.addEventListener('click', () => {
        const isPlaying = flmml.isPlaying();
        if (!isPlaying) {
            flmml.play(mml.getMml());
            flmml.addEventListener('compilecomplete', playAnimationStart);
        } else {
            flmml.stop();
            block.stopRendering();
            flmml.removeEventListener('compilecomplete', playAnimationStart);
        }
        playBtn.innerHTML = !isPlaying ? stopHtml : playHtml;
    });

    copyBtn.addEventListener('click', () => {
        const mmlText = mml.getMml();
        const textCache = copyBtn.innerHTML;
        copyBtn.disabled = true;
        navigator.clipboard.writeText(mmlText)
        .then(() => {
            copyBtn.disabled = true;
            copyBtn.innerHTML = createMIsHtml('content_copy') + 'コピーしました';
            setTimeout(() => {
                copyBtn.innerHTML = textCache;
                copyBtn.disabled = false;
            }, 1500);
        })
        .catch(e => alert('コピーできませんでした\n' + e));
    });

    saveBtn.addEventListener('click', () => {
        const mmlText = mml.getMml();
        const blob = new Blob([mmlText], {type: 'text/plain'});
        const link = document.createElement('a');
        link.download = 'Sequence' + '.mml';
        link.href = URL.createObjectURL(blob);
        link.click();
        URL.revokeObjectURL(link.href);
    });

    openBtn.addEventListener('click', () => {
        const inputFile = document.createElement('input');
        const fr = new FileReader();
        inputFile.type = 'file';
        inputFile.accept = '.mml,.flmml,.txt,text/plain'
        inputFile.click();
        inputFile.onchange = () => {
            fr.onload = () => {
                mml.setMml(fr.result);
                history.clear();
            };
            fr.readAsText(inputFile.files[0]);
        }
    });
});