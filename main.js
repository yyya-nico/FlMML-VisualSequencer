import './style.scss'
import 'mobile-drag-drop/default.css'
import FlMMLWorkerLocation from './flmml-on-html5.worker.js?url'

import {FlMML} from 'flmml-on-html5';
import localForage from 'localforage';
import {Picker} from 'emoji-picker-element';
import {polyfill} from 'mobile-drag-drop';
import {htmlspecialchars, resetAnimation, useVisualViewportToCss, waitScroll} from './utils';

const version = import.meta.env.VITE_APP_VER;

const editor = document.querySelector('.editor');
const tones = document.getElementById('tones');
const action = document.getElementById('action');
const musicalScore = document.getElementById('musical-score');
const addTrackBtn = document.getElementById('add-track');
const removeTrackBtn = document.getElementById('remove-track');
const dialog = document.getElementById('dialog');
const dialogForm = document.forms['dialog-form'];
dialogForm._title = dialogForm.querySelector('.form-title');
dialogForm.inputs = dialogForm.querySelector('.inputs');
dialogForm.buttons = dialogForm.querySelector('.buttons');
const playBtn = document.getElementById('play');
const clearBtn = document.getElementById('clear');
const warnOut = document.getElementById('warn-out');
const mmlOut = document.getElementById('mml');
const copyBtn = document.getElementById('copy');
const pasteBtn = document.getElementById('paste');
const saveBtn = document.getElementById('save');
const openBtn = document.getElementById('open');
const ctrlSw = document.getElementById('ctrl');
const undoBtn = document.getElementById('undo');
const redoBtn = document.getElementById('redo');

class Mml {
    #generatorComment = `#COMMENT Generated by FlMML VisualSequencer ${version}`;
    #mml = [];
    #changeHandler = (arr, mmlText) => {};
    #errorHandler = (error, reason) => {};

    set onChange(fn) {
        this.#changeHandler = fn;
    }

    set onError(fn) {
        this.#errorHandler = fn;
    }

    setMmlArr(arr) {
        this.#mml = arr;
        this.#changeHandler(this.getMmlArr(), this.getMml());
    }

    setMml(str) {
        this.#mml = str.split('\n');
        const isGeneratedMmlText = this.#mml.at(-2) === '' && this.#mml.at(-1) === this.#generatorComment;
        if (isGeneratedMmlText) {
            this.#mml.splice(-2, 2);
        }
        this.#changeHandler(this.getMmlArr(), this.getMml());
    }

    getMmlArr() {
        return this.#mml;
    }

    getMml() {
        if (this.#mml.length) {
            return this.#mml.concat([
                '',
                this.#generatorComment
            ]).join('\n');
        } else {
            return '';
        }
    }

    getMmlLine(i) {
        return this.#mml[i];
    }

    insert(i, str) {
        const valid = Object.hasOwn(this.#mml, i) || i === 0;
        if (valid) {
            this.#mml.splice(i, 0, str);
            this.#changeHandler(this.getMmlArr(), this.getMml());
        } else {
            this.#errorHandler('範囲外の書き換え指定', `範囲${this.#mml.length - 1}までのところ、${i}`);
        }
    }

    append(str) {
        this.#mml.push(str);
        this.#changeHandler(this.getMmlArr(), this.getMml());
    }

    appendToStr(i, str) {
        const valid = Object.hasOwn(this.#mml, i);
        if (valid) {
            this.#mml[i] += str;
            this.#changeHandler(this.getMmlArr(), this.getMml());
        } else {
            this.append(str);
        }
    }

    beforeInsertToStr(i, str) {
        const valid = Object.hasOwn(this.#mml, i);
        if (valid) {
            this.#mml[i] = str + this.#mml[i];
            this.#changeHandler(this.getMmlArr(), this.getMml());
        } else {
            this.append(str);
        }
    }

    rewrite(i, str) {
        const valid = Object.hasOwn(this.#mml, i);
        if (valid) {
            this.#mml[i] = str;
            this.#changeHandler(this.getMmlArr(), this.getMml());
        } else {
            this.append(str);
        }
    }

    delete(i, delCount = 1) {
        const valid = Object.hasOwn(this.#mml, i);
        if (valid && this.#mml.splice(i, delCount).length !== 0) {
            this.#changeHandler(this.getMmlArr(), this.getMml());
        } else {
            this.#errorHandler('無効な指定', `範囲${this.#mml.length - 1}までの中で${i}から${delCount}削除するのはできません`);
        }
    }
}

class BlockManager {
    #blocksData = [];
    #rAFs = [];
    #saveDelayTimer = null;
    #activeTrack = null;

    constructor(tones, areaElem) {
        this.tonesElem = tones;
        this.areaElem = areaElem;
        this.#activeTrack = this.areaElem.querySelector('.track.active');
    }

    set activeTrack(track) {
        this.#activeTrack.classList.remove('active');
        this.#activeTrack = track;
        this.#activeTrack.classList.add('active');
    }

    get activeTrack() {
        return this.#activeTrack;
    }

    blocksDataUpdate() {
        this.#blocksData = [...this.areaElem.querySelectorAll('.track button')].map(elem => ({
            label: elem.ariaLabel,
            className: elem.className,
            trackNo: [...document.getElementsByClassName('track')].findIndex(track => track.contains(elem)),
            tone: {
                tone: elem.dataset.tone,
                tonePitch: elem.dataset.tonePitch,
            },
            tempo: elem.dataset.tempo,
            noteValue: elem.dataset.noteValue,
            rest: elem.dataset.rest,
            octave: elem.dataset.octave,
            velocity: elem.dataset.velocity,
            noteShift: elem.dataset.noteShift,
            detune: elem.dataset.detune,
            tieSlur: elem.dataset.tieSlur,
            repeatStartEnd: elem.dataset.repeatStartEnd,
            repeatBreak: elem.dataset.repeatBreak,
            polyStartEnd: elem.dataset.polyStartEnd,
            macroDef: elem.dataset.macroDef,
            macroArgUse: elem.dataset.macroArgUse,
            macroUse: elem.dataset.macroUse,
            metaData: elem.dataset.metaData,
            otherAction: elem.dataset.otherAction,
            elem
        }));
    }

    saveBlocksData() {
        clearTimeout(this.#saveDelayTimer);
        this.#saveDelayTimer = setTimeout(() => {
            const modifiedData = JSON.parse(JSON.stringify(this.#blocksData));
            localForage.setItem('BlocksData', modifiedData)/* .then(() => console.log('saved')) */.catch(err => {
                alert('セーブができませんでした。' + err);
            });
        }, 1000);
    }

    checkSavedBlocksData() {
        localForage.getItem('BlocksData').then(data => {
            if (data) {
                this.#blocksData = data;
                this.parseBlocks();
                this.blocksDataUpdate();
                this.calcPoly();
                this.exportMml(mml);
            }
        });
    }

    parseBlocks() {
        const data = this.#blocksData;
        // console.log(data);
        this.activeTrack = this.areaElem.querySelector('.track');
        const tonesUl  = this.tonesElem.querySelector('ul');
        let trackNo = 0;
        data.forEach(block => {
            if (block.trackNo !== trackNo) {
                const newTrack = document.createElement('ul');
                newTrack.classList.add('track');
                this.activeTrack = newTrack;
                this.areaElem.insertBefore(newTrack, addTrackBtn);
                trackNo = block.trackNo;
            }
            const li = document.createElement('li');
            const toneButtonHTML = `<button class="material-icons note note-1" aria-label="無調整" draggable="true" data-tone="" data-tone-pitch="c">music_note</button>`;
            const toneButton = (() => {
                const wrap = document.createElement('div');
                wrap.innerHTML = toneButtonHTML;
                return wrap.firstElementChild;
            })();
            const copySourceCandidate = document.querySelector(`[class*="${block.className.replace(/ material-icons| droppable| bounce| pop| done/g, '')}"]`);
            const button = copySourceCandidate?.cloneNode(true) || toneButton;
            block.label && (button.ariaLabel = block.label);
            if (block.tone.tonePitch) {
                button.className = block.className;
                if (block.label !== '無調整') {
                    button.textContent = block.label;
                }
                button.dataset.tone = block.tone.tone;
                if (copySourceCandidate) {
                    copySourceCandidate.replaceWith(button.cloneNode(true));
                } else {
                    tonesUl.appendChild(button.cloneNode(true));
                }
                button.dataset.tonePitch = block.tone.tonePitch;
            }
            block.tempo && (button.dataset.tempo = block.tempo);
            block.noteValue && (button.dataset.noteValue = block.noteValue);
            block.rest && (button.dataset.rest = block.rest);
            block.octave && (button.dataset.octave = block.octave);
            block.velocity && (button.dataset.velocity = block.velocity);
            block.noteShift && (button.dataset.noteShift = block.noteShift);
            block.detune && (button.dataset.detune = block.detune);
            if (block.tieSlur) {
                button.dataset.tieSlur = block.tieSlur
                if (block.tieSlur === '&') {
                    button.ariaLabel = 'スラー';
                } else {
                    button.ariaLabel = 'タイ';
                }
            }
            if (block.repeatStartEnd) {
                button.dataset.repeatStartEnd = block.repeatStartEnd;
                if (block.repeatStartEnd.startsWith('/:')) {
                    button.classList.remove('material-icons');
                    button.ariaLabel = 'リピート開始';
                    button.textContent = '◆';
                } else if (block.repeatStartEnd === ':/') {
                    button.ariaLabel = 'リピート終了';
                }
            }
            block.repeatBreak && (button.dataset.repeatBreak = block.repeatBreak);
            block.polyStartEnd && (button.dataset.polyStartEnd = block.polyStartEnd);
            if (block.macroDef) {
                button.dataset.macroDef = block.macroDef;
                button.textContent = block.macroDef === ';' ? ';' : '$=' ;
            }
            block.macroArgUse && (button.dataset.macroArgUse = block.macroArgUse);
            block.macroUse && (button.dataset.macroUse = block.macroUse);
            block.metaData && (button.dataset.metaData = block.metaData);
            if (block.otherAction) {
                button.dataset.otherAction = block.otherAction;
                button.textContent = block.otherAction.length > 4 ? '…' : block.otherAction;
            }
            li.appendChild(button);
            this.activeTrack.appendChild(li);
        });
    }

    exportMml(mml) {
        mml.setMmlArr([]);
        let lineIndex = 0, trackNo = 0;
        const toneArr = this.#blocksData.filter(block => block.tone.tone !== undefined);
        const getTrackToneArr = () => toneArr.filter(block => block.trackNo === trackNo);
        const getToneSet = () => new Set(getTrackToneArr().map(block => block.tone.tone));
        let toneSet = getToneSet();
        let toneIndex = 0;
        let toneAppended = false;
        let scoreNoteValue = [4, 0], inPoly = false;
        this.#blocksData.forEach((block) => {
            const {tone, tonePitch} = block.tone;
            if (block.trackNo !== trackNo) {
                if (toneSet.size) {
                    [...toneSet].forEach((_, i) => {
                        mml.appendToStr(lineIndex + i, ';');
                    });
                    lineIndex += toneSet.size;
                } else {
                    mml.appendToStr(lineIndex, ';');
                    lineIndex++;
                }
                trackNo = block.trackNo;
                toneSet = getToneSet();
                toneAppended = false;
            }
            if (tone !== undefined) {
                toneIndex = [...toneSet].indexOf(tone);
                if (!toneAppended) {
                    [...toneSet].forEach((tone, i) => {
                        tone && mml.beforeInsertToStr(lineIndex + i, tone + ' ');
                    });
                    toneAppended = true;
                }
                [...toneSet].forEach((_, i) => {
                    let mmlText = tonePitch || '';
                    if (i !== toneIndex) {
                        mmlText = mmlText.replace(/[a-g]/, inPoly ? '*' : 'r');
                    }
                    mml.appendToStr(lineIndex + i, mmlText);
                });
            } else if (block.rest || block.tieSlur) {
                if (toneSet.size) {
                    [...toneSet].forEach((_, i) => {
                        mml.appendToStr(lineIndex + i, block.rest || block.tieSlur);
                    });
                } else {
                    mml.appendToStr(lineIndex, block.rest || block.tieSlur);
                }
            } else {
                if (block.noteValue || block.repeatStartEnd || block.repeatBreak || block.polyStartEnd) {
                    const noteValueStrCalc = str => {
                        if (!str) {
                            return scoreNoteValue;
                        }
                        const noteValue = Number((str.match(/[0-9]+/) || [scoreNoteValue[0]])[0]);
                        const dots = (str.match(/\.+/) || [''])[0].length;
                        return [noteValue, dots];
                    };
                    if (block.noteValue) {
                        scoreNoteValue = noteValueStrCalc(block.noteValue);
                    } else if (block.polyStartEnd === '[') {
                        inPoly = true;
                    } else if (block.polyStartEnd === ']') {
                        inPoly = false;
                    }
                    if (toneSet.size) {
                        [...toneSet].forEach((_, i) => {
                            mml.appendToStr(lineIndex + i, block.noteValue || block.repeatStartEnd || block.repeatBreak || block.polyStartEnd || '');
                            if (block.polyStartEnd === ']') {
                                const targetStr = mml.getMmlLine(lineIndex + i).match(/\[(.+?)\]/);
                                if (targetStr) {
                                    const matched = targetStr[1].matchAll(/([a-g*r]\+?)([0-9]*)(\.*)/g);
                                    if (matched) {
                                        const noteInfo = [...matched].map(arr => ({
                                            type: arr[1] === 'r' ? 'rest' :
                                                    arr[1] === '*' ? 'otherNote'
                                                                    : 'note',
                                            num: noteValueStrCalc(arr[0])
                                        }));
                                        const numsOf = {
                                            note: (() => {
                                                const noteOnlyInfo = noteInfo.filter(note => note.type === 'note');
                                                return noteOnlyInfo.map(note => note.num);
                                            })(),
                                            otherNote: (() => {
                                                const otherNoteOnlyInfo = noteInfo.filter(note => note.type === 'otherNote');
                                                return otherNoteOnlyInfo.map(note => note.num);
                                            })(),
                                            rest: (() => {
                                                const restOnlyInfo = noteInfo.filter(note => note.type === 'rest');
                                                return restOnlyInfo.map(note => note.num);
                                            })()
                                        };
                                        const getMaxNoteValue = arr => arr.reduce((accum, num) => {
                                            if (accum[0] >= num[0]) {
                                                if (accum[1] <= num[1]) {
                                                    return num;
                                                } else {
                                                    return accum;
                                                }
                                            } else {
                                                return accum;
                                            }
                                        }, [386, 0]);
                                        // TODO

                                        // const maxNoteNoteValue = getMaxNoteValue(numsOf.note);
                                        // const maxOtherNoteNoteValue = getMaxNoteValue(numsOf.otherNote);
                                        // const restNoteTime = numsOf.rest.reduce((sum, num) => sum + 4 / num, 0);
                                        // const getMaxNoteTime = maxNoteValue => (maxNoteValue[0] * 2 ** maxNoteValue[1]) / (2 ** (maxNoteValue[1] + 1) - 1);
                                        let replaceMmlText = targetStr[0].replace(/\*\+?[0-9]*\.*/g, '');
                                        // console.log(getMaxNoteTime(maxNoteNoteValue), getMaxNoteTime(maxOtherNoteNoteValue));
                                        // if (getMaxNoteTime(maxNoteNoteValue) < getMaxNoteTime(maxOtherNoteNoteValue)) {
                                        //     replaceMmlText = `${replaceMmlText.slice(0, -1)}r${maxOtherNoteNoteValue[0]}${'.'.repeat(maxOtherNoteNoteValue[1])}]`;
                                        // }
                                        const mmlText = mml.getMmlLine(lineIndex + i).replace(/\[.+?\]/, replaceMmlText);
                                        mml.rewrite(lineIndex + i, mmlText);
                                    }
                                }
                            }
                        });
                    } else {
                        mml.appendToStr(lineIndex, block.noteValue || block.repeatStartEnd || block.repeatBreak || block.polyStartEnd || '');
                    }
                } else if (block.metaData) {
                    if (block.metaData && mml.getMmlLine(lineIndex)) {
                        lineIndex++;
                    }
                    mml.appendToStr(lineIndex, block.metaData.replace('\n', '') || '');
                    lineIndex++;
                } else {
                    const mmlText = tonePitch || block.tempo || block.octave || block.velocity
                        || block.noteShift || block.detune || block.tieSlur || block.macroDef
                        || block.macroArgUse || block.macroUse || block.otherAction || '';
                    mml.appendToStr(lineIndex, mmlText);
                    if (/;/.test(mmlText)) {
                        lineIndex += toneSet.size || 1;
                        toneSet = getToneSet();
                        toneAppended = false;
                    }
                }
            }
        });
        [...toneSet].slice(0, -1).forEach((_, i) => {
            mml.appendToStr(lineIndex + i, ';');
        });
    }

    importMml(mml) {
        const mmlArr = mml.getMmlArr();
        const regex = /((@(l|q|x|p|u|mh|w|n|f|e|'[aeiou]?'|o|i|r|s)?|q|x)[0-9\-, ]+)+|[><]*?[a-g]\+?[0-9]*\.*|t[0-9]+|l[0-9]+\.*|r[0-9]*\.*|o[0-8]|[><]+|@?v[0-9]+|[\)\(][0-9]+|@?ns-?[0-9]+|@d-?[0-9]+|&[0-9]*\.*|\/\*.*?\*\/|\/\*|\*\/|\/:[0-9]*|:\/|\/|\[|\]|\$.*?=|%[a-z0-9_]+|\$[a-z0-9_]+(\{[^\}]*\})?|^#.*|;| +|@pl[0-9]+|[^;]+/ig;
        /* tone.tone|tone.tonePitch|tempo|noteValue|rest|octave|velocity|noteShift|detune|tieSlur|comment|repeatStartEnd|repeatBreak|polyStartEnd|macroDef|macroArgUse|macroUse|metaData|newTrack|space|otherAction */
        const data = [];
        const macroDefSet = new Set();
        const toneSet = new Set();
        let trackNo = 0;
        let toneCache = ''
        let inMacro = false, noteExist = false;
        mmlArr.forEach(mmlTextLine => {
            const matched = mmlTextLine.match(regex);
            (matched || []).forEach(str => {
                str = str.trim();
                if (!str) {
                    return;
                }
                const makeAndPushObj = str => {
                    const obj = {};
                    obj.tone = {};
                    obj.trackNo = trackNo;
                    if (/((@(l|q|x|p|u|mh|w|n|f|e|'[aeiou]?'|o|i|r|s)?|q|x)[0-9\-, ]+)+/i.test(str)) {
                        toneCache = str;
                        toneSet.add(toneCache);
                        return;
                    } else if (/^[><]*?[a-g]\+?[0-9]*\.*$/i.test(str)) {
                        if (!toneSet.has(toneCache)) {
                            toneSet.add(toneCache);
                        }
                        const noteCount = [...toneSet].indexOf(toneCache) + 1;
                        obj.label = '無調整';
                        obj.className = `material-icons note note-${noteCount}`;
                        obj.tone.tone = toneCache;
                        obj.tone.tonePitch = str;
                        inMacro && (noteExist = true);
                    } else if (str.startsWith('t')) {
                        obj.className = 'material-icons tempo';
                        obj.tempo = str;
                    } else if (str.startsWith('l')) {
                        obj.className = 'material-icons note-value';
                        obj.noteValue = str;
                    } else if (str.startsWith('r')) {
                        obj.className = 'material-icons rest';
                        obj.rest = str;
                    } else if (/^o[0-8]|[><]+$/i.test(str)) {
                        obj.className = 'material-icons octave';
                        obj.octave = str;
                    } else if (/^@?v[0-9]+|[\)\(][0-9]+$/i.test(str)) {
                        obj.className = 'material-icons velocity';
                        obj.velocity = str;
                    } else if (str.startsWith('@ns') || str.startsWith('ns')) {
                        obj.className = 'material-icons note-shift';
                        obj.noteShift = str;
                    } else if (str.startsWith('@d')) {
                        obj.className = 'material-icons detune';
                        obj.detune = str;
                    } else if (str.startsWith('&')) {
                        obj.className = 'tie-slur';
                        obj.tieSlur = str;
                    } else if (str.startsWith('/*')) {
                        obj.className = 'other-action';
                        obj.otherAction = str;
                    } else if (str.startsWith('/:')) {
                        obj.className = 'repeat-start-end';
                        obj.repeatStartEnd = str;
                    } else if (str.startsWith(':/')) {
                        obj.className = 'material-icons repeat-start-end';
                        obj.repeatStartEnd = str;
                    } else if (str.startsWith('/')) {
                        obj.className = 'repeat-break';
                        obj.repeatBreak = str;
                    } else if (str.startsWith('[') || str.startsWith(']')) {
                        obj.className = 'poly-start-end';
                        obj.polyStartEnd = str;
                    } else if (/^\$.*?=$/.test(str)) {
                        obj.className = 'macro-def';
                        obj.macroDef = str.replaceAll(' ', '');
                        macroDefSet.add(obj.macroDef.slice(0, -1));
                        inMacro = true;
                    } else if (str.startsWith('%')) {
                        obj.className = 'macro-arg-use';
                        obj.macroArgUse = str;
                    } else if (str.startsWith('$')) {
                        obj.className = 'macro-use';
                        const findMacroDef = [...macroDefSet].sort((a, b) => b.length - a.length).find(def => str.includes(def));
                        if (findMacroDef) {
                            obj.macroUse = findMacroDef;
                            data.push(obj);
                            const remaining = str.replace(findMacroDef, '');
                            if (remaining !== '') {
                                makeAndPushObj(remaining);
                            }
                            return
                        } else {
                            obj.macroUse = str;
                        }
                    } else if (str.startsWith('#')) {
                        const typeDefs = {
                            '#TITLE': 'タイトル',
                            '#ARTIST': 'アーティスト',
                            '#COMMENT': 'コメント',
                            '#CODING': '作成者',
                            '#PRAGMA': 'PRAGMA',
                            '#OCTAVE': '相対オクターブ反転',
                            '#VELOCITY REVERSE': '相対ベロシティ反転',
                            '#WAV9': '@9 波形データ',
                            '#WAV10': '@10 波形データ',
                            '#WAV13': '@13 波形データ',
                            '#OPM': '@14 OPM音色データ',
                            '#OPN': '@14 OPN音色データ',
                            '#FMGAIN': '@14 音量利得',
                            '#USING': '和音利用宣言',
                        };
                        obj.label = (Object.entries(typeDefs).find(def => str.startsWith(def[0])) || [,undefined])[1];
                        obj.className = 'meta-data';
                        obj.metaData = str + '\n';
                    } else if (str.startsWith(';')) {
                        trackNo++;
                        if (inMacro && !noteExist) {
                            const tone = [...toneSet].join(' ');
                            if (tone) {
                                obj.className = 'other-action';
                                obj.otherAction = tone;
                                data.push(obj);
                                toneSet.clear();
                            }
                        }
                        inMacro = false;
                        noteExist = false;
                        return;
                    } else {
                        obj.className = 'other-action';
                        obj.otherAction = str;
                    }
                    data.push(obj);
                };
                makeAndPushObj(str);
            });
        });
        this.tonesElem.querySelector('ul').textContent = '';
        this.areaElem.querySelectorAll('.track').forEach((track, notFirst) => {
            if (notFirst) {
                track.remove();
            } else {
                track.textContent = '';
                this.activeTrack = track;
            }
        });
        lastTouchedButton = null;
        this.#blocksData = data;
        this.parseBlocks();
        this.blocksDataUpdate();
        this.calcPoly();
        this.saveBlocksData();
    }

    playRendering() {
        const allData = this.#blocksData;
        let tempo = 120;
        let rAFIdBase = 0;
        [tones, action, musicalScore].forEach(target => {
            target.classList.add('no-op');
        });
        const wrap = document.querySelector('.wrap');
        // const headerHeight = Number(getComputedStyle(document.querySelector(':root')).getPropertyValue('--header-height').replace('px',''));
        // const scrTo = (top) => {
        //     top -= headerHeight;
        //     wrap.scrollTo({top, behavior: 'smooth'});
        // };
        // scrTo(musicalScore.offsetTop - 10);
        const tracks = document.getElementsByClassName('track');
        const wrapHeight = wrap.clientHeight;
        const trackHeight = (wrapHeight - (10 + 1 + 10 + 1 + 10)) / tracks.length;
        [...tracks].forEach(track => {
            track.style.setProperty('--max-height', `${trackHeight}px`);
        });
        addTrackBtn.disabled = true;
        removeTrackBtn.disabled = true;
        const rendPerTrack = (data, {scoreNoteValue = 4} = {}) => {
            let skip = false, jump = -1, nest = -1, inMacro = false;
            let scrWaiting = false;
            const repeatStart = [], repeatEnd = [], remainingRepeat = [];
            const start = performance.now();
            const trackNo = data[0]?.trackNo;
            const track = tracks[trackNo];
            const rAFId = rAFIdBase++;
            let resolve = null;
            const promise = new Promise(res => resolve = res);
            let totalDelay = 0;
            let i = 0;
            const noteValueStrCalc = str => {
                if (!str) {
                    return scoreNoteValue;
                }
                const matched = /(?:[a-g]\+?|[lr&])([0-9]*)(\.*)/.exec(str);
                const noteValue = matched && matched[1] ? Number(matched[1]) : scoreNoteValue;
                const dots = matched ? matched[2].length : 0;
                return (noteValue * 2 ** dots) / (2 ** (dots + 1) - 1);
            };
            const scrollTask = current => {
                const scrTo = (top) => {
                    !scrWaiting && track.scrollTo({top, behavior: 'smooth'});
                    scrWaiting = true;
                    waitScroll(track).then(() => {
                        scrWaiting = false;
                    });
                };
                const criHeiPercentage = ratio => {
                    return track.clientHeight * ratio;
                };
                if (i === 0 || current.elem.offsetTop >  track.scrollTop + criHeiPercentage(0.8) || current.elem.offsetTop < track.scrollTop + criHeiPercentage(0.2)) {
                    scrTo(current.elem.offsetTop - criHeiPercentage(0.2));
                }
            };
            const delayAttachMotion = noteValue => {
                const repeatFunc = timeStamp => {
                    const elapsed = timeStamp - start;
                    const delay = 60 / tempo * 4 / noteValue * 1000;
                    if (elapsed < totalDelay + delay) {
                        this.#rAFs[rAFId] = requestAnimationFrame(repeatFunc);
                    } else {
                        totalDelay += delay;
                        attachMotion();
                    }
                }
                this.#rAFs[rAFId] = requestAnimationFrame(repeatFunc);
            };
            const attachMotion = async () => {
                const current = data[i];
                if (!current || i >= data.length) {
                    resolve({
                        scoreNoteValue
                    });
                    return;
                }
                scrollTask(current);
                if (inMacro) {
                    if (current.macroDef === ';') {
                        inMacro = false;
                    }
                    i++;
                    attachMotion();
                    return;
                } else if (jump !== -1) {
                    if (current.repeatStartEnd?.startsWith('/:')) {
                        nest++;
                    } else if (current.repeatStartEnd === ':/') {
                        if (nest === jump) {
                            resetAnimation(current.elem, 'pop');
                            jump = -1;
                        }
                        nest--;
                    }
                    i++;
                    attachMotion();
                } else if (current.tone.tonePitch) {
                    const currentNoteValue = noteValueStrCalc(current.tone.tonePitch);
                    resetAnimation(current.elem, 'bounce');
                    i++;
                    if (!skip) {
                        delayAttachMotion(currentNoteValue);
                    } else {
                        attachMotion();
                    }
                } else if (current.rest || current.tieSlur) {
                    resetAnimation(current.elem, 'pop');
                    i++;
                    if (current.tieSlur === '&') {
                        attachMotion();
                    } else {
                        const currentNoteValue = noteValueStrCalc(current.rest || current.tieSlur);
                        delayAttachMotion(currentNoteValue);
                    }
                } else if (current.polyStartEnd) {
                    skip = current.polyStartEnd === '[';
                    resetAnimation(current.elem, 'pop');
                    if (!skip) {
                        const previousNoteValue = noteValueStrCalc(data[i++ - 1].tone.tonePitch);
                        delayAttachMotion(previousNoteValue);
                    } else {
                        i++;
                        attachMotion();
                    }
                } else if (current.macroDef && current.macroDef !== ';') {
                    inMacro = true;
                    i++;
                    attachMotion();
                    return;
                } else {
                    current.tempo && (tempo = Number(current.tempo.replace('t', '')) || tempo);
                    current.noteValue && (scoreNoteValue = noteValueStrCalc(current.noteValue));
                    resetAnimation(current.elem, 'pop');
                    if (current.repeatStartEnd?.startsWith('/:')) {
                        repeatStart[++nest] = i;
                        if (!repeatEnd[nest]) {
                            remainingRepeat[nest] = current.repeatStartEnd.replace('/:', '');
                            remainingRepeat[nest] = remainingRepeat[nest] === '' ? 2 : Number(remainingRepeat[nest]);
                            if (!remainingRepeat[nest]) {
                                jump = nest;
                            }
                        }
                    } else if (current.repeatBreak) {
                        if (remainingRepeat[nest] === 1) {
                            if (!repeatEnd[nest]) {
                                let tempNest = nest;
                                repeatEnd[nest] = data.findIndex((block, i) => {
                                    if (i > repeatStart[nest]) {
                                        console.log(tempNest);
                                        if (block.repeatStartEnd.startsWith('/:')) {
                                            tempNest++;
                                        } else if (block.repeatStartEnd === ':/') {
                                            if (tempNest === nest) {
                                                return true;
                                            }
                                            tempNest--;
                                        }
                                    }
                                });
                            }
                            i = repeatEnd[nest];
                            attachMotion();
                            resetAnimation(current.elem, 'done');
                            return;
                        }
                    } else if (current.repeatStartEnd === ':/') {
                        remainingRepeat[nest]--;
                        if (remainingRepeat[nest]) {
                            repeatEnd[nest] = i;
                            i = repeatStart[nest];
                            nest--;
                            attachMotion();
                            resetAnimation(current.elem, 'done');
                            return;
                        }
                        repeatEnd[nest] = null;
                        nest--;
                    } else if (current.macroUse) {
                        const findMacroEndIndex = start => {
                            const trackNo = allData[start].trackNo;
                            let end = start + 1;
                            while (allData[end].macroDef !== ';' && allData[end].trackNo === trackNo) {
                                end++;
                            };
                            return end;
                        };
                        const targetMacro = {};
                        targetMacro.start = allData.findIndex(block => block.macroDef?.startsWith(current.macroUse));
                        if (targetMacro.start > -1) {
                            targetMacro.end = findMacroEndIndex(targetMacro.start);
                            targetMacro.blocks = allData.slice(targetMacro.start + 1, targetMacro.end);
                            const start = performance.now();
                            scoreNoteValue = (await rendPerTrack(targetMacro.blocks, {scoreNoteValue})).scoreNoteValue;
                            const end = performance.now();
                            totalDelay += end - start;
                        }
                    }
                    i++;
                    attachMotion();
                }
                resetAnimation(current.elem, 'done');
            }
            attachMotion();
            return promise;
        }
        const numOfTracks = Math.max(...allData.map(block => block.trackNo)) + 1;
        for (let trackNo = 0; trackNo < numOfTracks; trackNo++) {
            rendPerTrack(allData.filter(block => block.trackNo === trackNo));
        }
    }

    stopRendering() {
        [tones, action, musicalScore].forEach(target => {
            target.classList.remove('no-op');
        });
        addTrackBtn.disabled = false;
        removeTrackBtn.disabled = false;
        this.#blocksData.forEach(block => {
            block.elem.classList.remove('done');
        });
        this.#rAFs.forEach(rAF => {
            cancelAnimationFrame(rAF);
        });
    }

    calcPoly() {
        const numOfTracks = Math.max(...this.#blocksData.map(block => block.trackNo)) + 1;
        for (let trackNo = 0; trackNo < numOfTracks; trackNo++) {
            const polyBlocksData = this.#blocksData.filter(block => block.polyStartEnd && block.trackNo === trackNo);
            polyBlocksData.forEach((block, i) => {
                if (i % 2 === 0) {
                    block.elem.dataset.polyStartEnd = '[';
                    block.elem.textContent = '[';
                } else {
                    block.elem.dataset.polyStartEnd = ']';
                    block.elem.textContent = ']';
                }
            });
        }
        this.blocksDataUpdate();
    }
}

class History {
    #histArr = [[],[]];
    #maxArrLength = 70;
    #pushstateHandler = obj => {};
    #popstateHandler = obj => {};

    set onPushstate(fn) {
        this.#pushstateHandler = fn;
    }

    set onPopstate(fn) {
        this.#popstateHandler = fn;
    }

    pushState(obj) {
        this.#histArr[0].push(obj);
        this.#pushstateHandler(obj);
        if (this.#histArr[0].length > this.#maxArrLength) {
            this.#histArr[0].shift();
        }
        this.#histArr[1].length = 0;
        console.log(this.#histArr);
    }

    undo() {
        const data = this.#histArr[0].pop();
        this.#popstateHandler({
            reason: 'undo',
            data
        });
        data && this.#histArr[1].unshift(data);
        console.log(this.#histArr);
        const status = {
            canUndo: Boolean(this.#histArr[0].length),
            canRedo: Boolean(this.#histArr[1].length)
        };
        return status;
    }

    redo() {
        const data = this.#histArr[1].shift();
        this.#popstateHandler({
            reason: 'redo',
            data
        });
        data && this.#histArr[0].push(data);
        console.log(this.#histArr);
        const status = {
            canUndo: Boolean(this.#histArr[0].length),
            canRedo: Boolean(this.#histArr[1].length)
        };
        return status;
    }

    clear() {
        this.#histArr[0].length = 0;
        this.#histArr[1].length = 0;
        console.log(this.#histArr);
    }
}

class DialogFormManager {
    #dialogDefinitions = {
        tone: {
            title: '音色設定',
            inputs: [
                {
                    label: '名前',
                    type: 'text',
                    name: 'tone-name'
                },
                {
                    label: '音の定義',
                    type: 'text',
                    name: 'tone-def',
                    autofocus: ''
                }
            ],
            buttons: [
                {
                    class: 'primaly',
                    value: 'set-tone',
                    textContent: '確定'
                }
            ]
        },
        tonePitch: {
            title: '音価設定',
            inputs: [
                {
                    label: '音価(音の長さ)',
                    type: 'number',
                    name: 'tone-pitch',
                    min: '1',
                    max: '384'
                },
                {
                    label: '付点の数',
                    type: 'number',
                    name: 'dot',
                    min: '0'
                }
            ],
            buttons: [
                {
                    class: 'primaly',
                    value: 'set-tone-pitch',
                    textContent: '確定'
                }
            ]
        },
        tempo: {
            title: 'テンポ設定',
            inputs: [
                {
                    label: 'テンポ指定(BPM)',
                    type: 'number',
                    name: 'tempo',
                    min: '0'
                }
            ],
            buttons: [
                {
                    class: 'primaly',
                    value: 'set-tempo',
                    textContent: '確定'
                }
            ]
        },
        noteValue: {
            title: '音価設定',
            inputs: [
                {
                    label: '音価(音の長さ)',
                    type: 'number',
                    name: 'note-value',
                    min: '1',
                    max: '384'
                },
                {
                    label: '付点の数',
                    type: 'number',
                    name: 'dot',
                    min: '0'
                }
            ],
            buttons: [
                {
                    class: 'primaly',
                    value: 'set-note-value',
                    textContent: '確定'
                }
            ]
        },
        rest: {
            title: '休符設定',
            inputs: [
                {
                    label: '休符の長さ',
                    type: 'number',
                    name: 'rest',
                    min: '1',
                    max: '384'
                },
                {
                    label: '付点の数',
                    type: 'number',
                    name: 'dot',
                    min: '0'
                }
            ],
            buttons: [
                {
                    class: 'primaly',
                    value: 'set-rest',
                    textContent: '確定'
                }
            ]
        },
        octave: {
            title: 'オクターブ設定',
            inputs: [
                {
                    label: 'オクターブ位置',
                    type: 'number',
                    name: 'octave',
                    min: '-8',
                    max: '8'
                }
            ],
            buttons: [
                {
                    class: 'primaly',
                    value: 'set-octave',
                    textContent: '絶対指定'
                },
                {
                    value: 'set-octave-relative',
                    textContent: '相対指定'
                }
            ]
        },
        velocity: {
            title: '音量設定',
            inputs: [
                {
                    label: '音量',
                    type: 'number',
                    name: 'velocity',
                    min: '-127',
                    max: '127'
                }
            ],
            buttons: [
                {
                    class: 'primaly',
                    value: 'set-velocity',
                    textContent: '絶対指定'
                },
                {
                    value: 'set-velocity-relative',
                    textContent: '相対指定'
                }
            ]
        },
        noteShift: {
            title: 'ノートシフト設定',
            inputs: [
                {
                    label: 'シフト量',
                    type: 'number',
                    name: 'note-shift'
                }
            ],
            buttons: [
                {
                    class: 'primaly',
                    value: 'set-note-shift',
                    textContent: '絶対指定'
                },
                {
                    value: 'set-note-shift-relative',
                    textContent: '相対指定'
                }
            ]
        },
        detune: {
            title: 'デチューン設定',
            inputs: [
                {
                    label: 'デチューン量',
                    type: 'number',
                    name: 'detune'
                }
            ],
            buttons: [
                {
                    class: 'primaly',
                    value: 'set-detune',
                    textContent: '確定'
                }
            ]
        },
        tieSlur: {
            title: 'タイ設定',
            inputs: [
                {
                    label: '音価(音の長さ)',
                    type: 'number',
                    name: 'tie-slur',
                    min: '1',
                    max: '384'
                },
                {
                    label: '付点の数',
                    type: 'number',
                    name: 'dot',
                    min: '0'
                }
            ],
            buttons: [
                {
                    class: 'primaly',
                    value: 'set-tie-slur',
                    textContent: '確定'
                }
            ]
        },
        repeatStartEnd: {
            title: 'ループ設定',
            inputs: [
                {
                    label: 'ループ回数',
                    type: 'number',
                    name: 'repeat',
                    min: '0'
                }
            ],
            buttons: [
                {
                    class: 'primaly',
                    value: 'set-repeat',
                    textContent: '確定'
                }
            ]
        },
        macroDef: {
            title: 'マクロ定義設定',
            inputs: [
                {
                    label: '名前',
                    type: 'text',
                    name: 'macro-def-name'
                },
                {
                    label: '引数 カンマ区切り',
                    type: 'text',
                    name: 'macro-def-arg'
                }
            ],
            buttons: [
                {
                    class: 'primaly',
                    value: 'set-macro-def',
                    textContent: '確定'
                }
            ]
        },
        macroArgUse: {
            title: 'マクロ引数使用設定',
            inputs: [
                {
                    label: '引数名',
                    type: 'text',
                    name: 'macro-arg-use'
                }
            ],
            buttons: [
                {
                    class: 'primaly',
                    value: 'set-macro-arg-use',
                    textContent: '確定'
                }
            ]
        },
        macroUse: {
            title: 'マクロ使用設定',
            inputs: [
                {
                    label: '名前',
                    type: 'text',
                    name: 'macro-use-name'
                },
                {
                    label: '引数 カンマ区切り',
                    type: 'text',
                    name: 'macro-use-arg'
                },
            ],
            buttons: [
                {
                    class: 'primaly',
                    value: 'set-macro-use',
                    textContent: '確定'
                }
            ]
        },
        metaData: {
            title: 'メタデータ設定',
            inputs: [
                {
                    label: '定義選択',
                    select: {
                        '#TITLE {desc}\n': 'タイトル',
                        '#ARTIST {desc}\n': 'アーティスト',
                        '#COMMENT {desc}\n': 'コメント',
                        '#CODING {desc}\n': '作成者',
                        '#PRAGMA {desc}\n': 'PRAGMA',
                        '#OCTAVE REVERSE\n': '相対オクターブ反転',
                        '#VELOCITY REVERSE\n': '相対ベロシティ反転',
                        '#WAV9 {n},{desc}\n': '@9 波形データ',
                        '#WAV10 {n},{desc}\n': '@10 波形データ',
                        '#WAV13 {n},{desc}\n': '@13 波形データ',
                        '#OPM@{n} {{desc}}\n': '@14 OPM音色データ',
                        '#OPN@{n} {{desc}}\n': '@14 OPN音色データ',
                        '#FMGAIN {n}\n': '@14 音量利得',
                        '#USING POLY {n} force\n': '和音利用宣言',
                    },
                    name: 'select-meta-data'
                },
                {
                    label: ' ',
                    type: 'number',
                    name: 'number',
                },
                {
                    label: ' ',
                    type: 'text',
                    name: 'text'
                },
            ],
            buttons: [
                {
                    class: 'primaly',
                    value: 'set-meta-data',
                    textContent: '確定'
                }
            ]
        },
        otherAction: {
            title: 'その他の作用設定',
            inputs: [
                {
                    label: '任意のMML',
                    type: 'text',
                    name: 'other-action'
                }
            ],
            buttons: [
                {
                    class: 'primaly',
                    value: 'set-other-action',
                    textContent: '確定'
                }
            ]
        },
        remove: {
            title: '一部の消去メニュー',
            buttons: [
                {
                    value: 'remove-left',
                    textContent: 'このブロックから左をすべて消去'
                },
                {
                    value: 'remove-right',
                    textContent: 'このブロックから右をすべて消去'
                },
            ]
        }
    }
    #createElems = (type) => {
        const def = this.#dialogDefinitions[type];
        Object.keys(def).forEach(key => {
            switch (key) {
                case 'title':
                    dialogForm._title.textContent = def.title;
                    break;
                case 'inputs':
                    def.inputs.forEach(inputDef => {
                        const input = document.createElement('input');
                        let appendElem = input;
                        Object.entries(inputDef).forEach(entry => {
                            if (entry[0] === 'label') {
                                const label = document.createElement('label');
                                label.innerHTML = entry[1];
                                label.appendChild(input);
                                appendElem = label;
                            } else if (entry[0] === 'select') {
                                const select = document.createElement('select');
                                select.name = inputDef.name;
                                const selectOptionsDef = entry[1];
                                Object.entries(selectOptionsDef).forEach(entry => {
                                    const option = document.createElement('option');
                                    option.value = entry[0];
                                    option.textContent = entry[1];
                                    select.appendChild(option);
                                });
                                input.replaceWith(select);
                            } else {
                                input.setAttribute(entry[0], entry[1]);
                            }
                        });
                        dialogForm.inputs.appendChild(appendElem);
                    });
                    break;
                case 'buttons':
                    def.buttons.forEach(buttonDef => {
                        const button = document.createElement('button');
                        Object.entries(buttonDef).forEach(([key, value]) => {
                            button[key] = value;
                        });
                        dialogForm.buttons.appendChild(button);
                    });
                    break;
            }
        });
    }

    #set = (type, initVals) => {
        dialogForm._title.textContent = '';
        dialogForm.inputs.textContent = '';
        dialogForm.buttons.textContent = '';
        this.#createElems(type);
        for (const [name, value] of Object.entries(initVals)) {
            if (name === 'run') {
                value();
            } else {
                dialogForm.elements[name].value = value;
            }
        }
        this.type = type;
    }

    constructor(dialogForm) {
        this.type = null;
        this.submitTarget = null;
        this.resolve = null;
        dialogForm.addEventListener('submit', e => {
            const submitTarget = this.submitTarget;
            const submitterVal = e.submitter.value;
            const beforeChange = JSON.parse(JSON.stringify(submitTarget.dataset));
            switch (submitterVal) {
                case 'set-tone':
                    const buttonClassName = submitTarget.className;
                    document.querySelectorAll(`[class*="${buttonClassName}"]`).forEach(elem => {
                        elem.ariaLabel = dialogForm.elements['tone-name'].value;
                        if (!elem.classList.contains('material-icons') || dialogForm.elements['tone-name'].value !== '無調整') {
                            elem.classList.remove('material-icons');
                            elem.textContent = dialogForm.elements['tone-name'].value;
                        }
                        elem.dataset.tone = dialogForm.elements['tone-def'].value;
                    });
                    break;
                case 'set-tone-pitch':
                    submitTarget.dataset.tonePitch = submitTarget.dataset.tonePitch.match(/[><]*?[a-g]\+?/)[0] + dialogForm.elements['tone-pitch'].value + '.'.repeat(dialogForm.elements['dot'].value);
                    break;
                case 'set-tempo':
                    submitTarget.dataset.tempo = 't' + dialogForm.elements['tempo'].value;
                    break;
                case 'set-note-value':
                    submitTarget.dataset.noteValue = 'l' + dialogForm.elements['note-value'].value + '.'.repeat(dialogForm.elements['dot'].value);
                    break;
                case 'set-rest':
                    submitTarget.dataset.rest = 'r' + dialogForm.elements['rest'].value + '.'.repeat(dialogForm.elements['dot'].value);
                    break;
                case 'set-octave':
                    submitTarget.dataset.octave = 'o' + dialogForm.elements['octave'].value;
                    break;
                case 'set-octave-relative':
                    submitTarget.dataset.octave = dialogForm.elements['octave'].value > 0 ? '<'.repeat(dialogForm.elements['octave'].value) : '>'.repeat(-dialogForm.elements['octave'].value);
                    break;
                case 'set-velocity':
                    submitTarget.dataset.velocity = '@v' + dialogForm.elements['velocity'].value;
                    break;
                case 'set-velocity-relative':
                    submitTarget.dataset.velocity = (dialogForm.elements['velocity'].value >= 0 ? '(' : ')') + Math.abs(dialogForm.elements['velocity'].value);
                    break;
                case 'set-note-shift':
                    submitTarget.dataset.noteShift = 'ns' + dialogForm.elements['note-shift'].value;
                    break;
                case 'set-note-shift-relative':
                    submitTarget.dataset.noteShift = '@ns' + dialogForm.elements['note-shift'].value;
                    break;
                case 'set-detune':
                    submitTarget.dataset.detune = '@d' + dialogForm.elements['detune'].value;
                    break;
                case 'set-tie-slur':
                    submitTarget.dataset.tieSlur = '&' + dialogForm.elements['tie-slur'].value + '.'.repeat(dialogForm.elements['dot'].value);
                    if (submitTarget.dataset.tieSlur === '&') {
                        submitTarget.ariaLabel = 'スラー';
                    } else {
                        submitTarget.ariaLabel = 'タイ';
                    }
                    break;
                case 'set-repeat':
                    submitTarget.dataset.repeatStartEnd = '/:' + dialogForm.elements['repeat'].value;
                    break;
                case 'set-macro-def':
                    const beforeMacroDef = submitTarget.dataset.macroDef;
                    submitTarget.dataset.macroDef = '$' + dialogForm.elements['macro-def-name'].value
                        + (dialogForm.elements['macro-def-arg'].value !== '' ? `{${dialogForm.elements['macro-def-arg'].value}}` : '')
                        + '=';
                    musicalScore.querySelectorAll(`[data-macro-use="${beforeMacroDef.replace('=', '')}"]`).forEach(elem => {
                        elem.dataset.macroUse = submitTarget.dataset.macroDef.replace('=', '');
                    });
                    break;
                case 'set-macro-arg-use':
                    submitTarget.dataset.macroArgUse = '%' + dialogForm.elements['macro-arg-use'].value;
                    break;
                case 'set-macro-use':
                    submitTarget.dataset.macroUse = '$' + dialogForm.elements['macro-use-name'].value
                        + (dialogForm.elements['macro-use-arg'].value !== '' ? `{${dialogForm.elements['macro-use-arg'].value}}` : '');
                    break;
                case 'set-meta-data':
                    submitTarget.ariaLabel = dialogForm.elements['select-meta-data'].selectedOptions[0].label;
                    submitTarget.dataset.metaData = dialogForm.elements['select-meta-data'].value
                        .replace('{n}', dialogForm.elements['number'].value)
                        .replace('{desc}', dialogForm.elements['text'].value);
                    break;
                case 'set-other-action':
                    submitTarget.dataset.otherAction = dialogForm.elements['other-action'].value;
                    submitTarget.textContent = submitTarget.dataset.otherAction.length > 4 ? '…' : submitTarget.dataset.otherAction;
                    break;
                case 'remove-left':
                case 'remove-right':
                    const removeFrom = submitTarget.parentElement;
                    const activeTrackUl = blockManager.activeTrack;
                    const ulChildren = activeTrackUl.children;
                    const removeFromIndex = [...ulChildren].indexOf(removeFrom);
                    lastTouchedButton = null;
                    while ([...ulChildren].includes(removeFrom)) {
                        const isLeft = submitterVal === 'remove-left';
                        const removeTarget = isLeft ? activeTrackUl.firstElementChild
                                                    : activeTrackUl.lastElementChild;
                        history.pushState({
                            operation: 'remove',
                            removedElem: removeTarget,
                            removedIndex: isLeft ? 0 : ulChildren.length - 1,
                            parent: activeTrackUl
                        });
                        removeTarget.remove();
                    }
                    blockManager.blocksDataUpdate();
                    blockManager.calcPoly();
                    blockManager.saveBlocksData();
                    blockManager.exportMml(mml);
                    break;
            }
            const afterChange = JSON.parse(JSON.stringify(submitTarget.dataset));
            if (JSON.stringify(beforeChange) !== JSON.stringify(afterChange)) {
                history.pushState({
                    operation: 'valueChange',
                    target: submitTarget,
                    beforeChange,
                    afterChange
                });
            }
            this.resolve();
        });
    }

    async prompt(type, initVals, submitTarget) {
        this.#set(type, initVals);
        this.submitTarget = submitTarget;
        dialog.showModal();
        return new Promise(resolve => this.resolve = resolve);
    }
}

FlMML.prepare(`.editor`);
const flmml = new FlMML({workerURL: FlMMLWorkerLocation});
const mml = new Mml();
localForage.config({
    name        : 'FlMML-VisualSequencer',
    version     : 1.0,
    storeName   : 'backups',
    description : 'BlockData Object Backups'
});
const blockManager = new BlockManager(tones, musicalScore);
const history = new History();
const dialogFormManager = new DialogFormManager(dialogForm);
const ja = {
    "categories": {
        "custom": "カスタム",
        "smileys-emotion": "スマイリーと感情",
        "people-body": "人々と体",
        "animals-nature": "動物と自然",
        "food-drink": "食べ物と飲み物",
        "travel-places": "旅行と場所",
        "activities": "活動",
        "objects": "オブジェクト",
        "symbols": "シンボル",
        "flags": "フラグ"
    },
    "categoriesLabel": "カテゴリー",
    "emojiUnsupportedMessage": "お使いのブラウザはカラー絵文字に対応していません。",
    "favoritesLabel": "お気に入り",
    "loadingMessage": "読み込み中…",
    "networkErrorMessage": "絵文字を読み込めませんでした。",
    "regionLabel": "絵文字ピッカー",
    "searchDescription": "検索結果が利用可能な場合、上下キーを押して選択し、Enter キーを押して選択します。",
    "searchLabel": "検索",
    "searchResultsLabel": "検索結果",
    "skinToneDescription": "展開された状態で、上下キーを押して選択し、Enter キーを押して選択します。",
    "skinToneLabel": "スキントーンを選択してください（現在のスキントーンは {skinTone} です）",
    "skinTones": [
        "デフォルト",
        "ライト",
        "ミディアムライト",
        "ミディアム",
        "ミディアムダーク",
        "ダーク"
    ],
    "skinTonesLabel": "スキントーン"
}
const picker = new Picker({
    i18n: ja,
    locale: 'ja'
});
polyfill({
    holdToDrag: 500
});
useVisualViewportToCss();

const createMIsHtml = name => `<span class="material-icons">${name}</span>`;
const playHtml = createMIsHtml('play_arrow') + '再生';
const stopHtml = createMIsHtml('stop') + '停止';

const playAnimationStart = () => {
    blockManager.playRendering();
};
const compileHandler = () => {
    warnOut.innerHTML = flmml.getWarnings().replaceAll('\n','<br>');
};
flmml.addEventListener('compilecomplete', compileHandler);
const completeHandler = () => {
    playBtn.innerHTML = playHtml;
    blockManager.stopRendering();
    flmml.removeEventListener('compilecomplete', playAnimationStart);
    clearBtn.disabled = false;
};
flmml.addEventListener('complete', completeHandler);

mml.onChange = (arr, mmlText) => {
    mmlOut.innerHTML = mmlText ? `<pre><code>${htmlspecialchars(mmlText).replaceAll('\n','<br>')}</code></pre>` : '(なし)';
    const mmlIsExist = Boolean(arr.length);
    [copyBtn, saveBtn].forEach(elem => {
        elem.disabled = !mmlIsExist;
    });
};
mml.onError = (error, reason) => {
    alert(error + '\n' + reason);
};

blockManager.checkSavedBlocksData();

const playMusicNote = block => {
    const findNoteValueElem = () => {
        let findTemp = block.parentElement;
        while (findTemp && !('noteValue' in findTemp.firstElementChild.dataset)) {
            findTemp = findTemp.previousElementSibling;
        };
        return findTemp?.firstElementChild || null;
    };
    const findOctaveElem = () => {
        let findTemp = block.parentElement;
        while (findTemp && !(findTemp.firstElementChild.dataset.octave?.startsWith('o'))) {
            findTemp = findTemp.previousElementSibling;
        };
        return findTemp?.firstElementChild || null;
    };
    const concatTies = () => {
        let findTemp = block.parentElement.nextElementSibling;
        let ties = '';
        while (findTemp && findTemp.firstElementChild.dataset.tieSlur?.match(/&[0-9]+\.*/)) {
            ties += findTemp.firstElementChild.dataset.tieSlur;
            findTemp = findTemp.nextElementSibling;
        }
        return ties;
    };
    const scoreNoteValueMml = findNoteValueElem()?.dataset.noteValue || '';
    const absoluteOctaveMml = findOctaveElem()?.dataset.octave || '';
    const currentIndex = [...blockManager.activeTrack.children].indexOf(block.parentElement);
    const concatAllOctave = [...blockManager.activeTrack.children]
                                .slice(0, currentIndex)
                                .filter(li => 'tonePitch' in li.firstElementChild.dataset || 'octave' in li.firstElementChild.dataset && !li.firstElementChild.dataset.octave.startsWith('o'))
                                .map(li => {
                                    const pitch = li.firstElementChild.dataset.tonePitch || li.firstElementChild.dataset.octave;
                                    return (pitch.match(/[><]+/) || [''])[0];
                                }).join('');
    const octave = ['>', '<'];
    const countStr = (target, str) => (target.match(new RegExp(str, 'g')) || []).length;
    const currentRelativeOctave = (() => {
        const relativeOctaveNum = -countStr(concatAllOctave, octave[0]) + countStr(concatAllOctave, octave[1]);
        if (relativeOctaveNum < 0) {
            return octave[0].repeat(-relativeOctaveNum);
        } else if (relativeOctaveNum > 0) {
            return octave[1].repeat(relativeOctaveNum);
        } else {
            return '';
        }
    })();
    const ties = concatTies();
    flmml.play(block.dataset.tone + scoreNoteValueMml + absoluteOctaveMml + currentRelativeOctave + block.dataset.tonePitch + ties);
};

history.onPopstate = obj => {
    const data = obj.data;
    const is = id => Boolean(data.parent.closest('#' + id));
    switch (obj.reason) {
        case 'undo':
            switch (data?.operation) { //元に戻す操作集
                case 'append':
                    mml.delete(data.index);
                    break;
                case 'delete':
                    mml.insert(data.index, data.mmlText);
                    break;
                case 'rewrite':
                    mml.rewrite(data.index, data.beforeMmlText);
                    break;
                case 'copy':
                    data.newElem.remove();
                    if (is('musical-score')) {
                        blockManager.blocksDataUpdate();
                        blockManager.calcPoly();
                        blockManager.saveBlocksData();
                        blockManager.exportMml(mml);
                    }
                    break;
                case 'move':
                    const position = data.fromIndex <= data.toIndex ? 'beforebegin' : 'afterend';
                    data.parent.children[data.fromIndex].insertAdjacentElement(position, data.elem);
                    if (is('musical-score')) {
                        blockManager.blocksDataUpdate();
                        blockManager.calcPoly();
                        blockManager.saveBlocksData();
                        blockManager.exportMml(mml);
                    }
                    break;
                case 'valueChange':
                    for (const [name, value] of Object.entries(data.beforeChange)) {
                        data.target.dataset[name] = value;
                    }
                    if ('tone' in data.target.dataset) {
                        playMusicNote(data.target);
                    }
                    blockManager.blocksDataUpdate();
                    blockManager.saveBlocksData();
                    blockManager.exportMml(mml);
                    break;
                case 'remove':
                    data.parent.insertBefore(data.removedElem, data.parent.children[data.removedIndex]);
                    if (is('tones')) { //TODO
                    } else if (is('musical-score')) {
                        blockManager.blocksDataUpdate();
                        blockManager.calcPoly();
                        blockManager.saveBlocksData();
                        blockManager.exportMml(mml);
                    }
                    break;
                case 'clear':
                    data.tonesChildren.forEach(li => {
                        tones.querySelector('ul').appendChild(li);
                    });
                    data.musicalScoreChildren.forEach(li => {
                        musicalScore.insertBefore(li, addTrackBtn);
                    });
                    lastTouchedButton = data.lastTouchedButton;
                    blockManager.blocksDataUpdate();
                    blockManager.saveBlocksData();
                    blockManager.exportMml(mml);
                    break;
            }
            break;
        case 'redo':
            switch (data?.operation) { //やり直し操作集
                case 'append':
                    mml.append(data.mmlText);
                    break;
                case 'delete':
                    mml.delete(data.index);
                    break;
                case 'rewrite':
                    mml.rewrite(data.index, data.afterMmlText);
                    break;
                case 'copy':
                    if (data.toIndex !== -1) {
                        data.parent.insertBefore(data.newElem, data.parent.children[data.toIndex]);
                    } else {
                        data.parent.appendChild(data.newElem);
                    }
                    if (is('musical-score')) {
                        blockManager.blocksDataUpdate();
                        blockManager.calcPoly();
                        blockManager.saveBlocksData();
                        blockManager.exportMml(mml);
                    }
                    if ('tonePitch' in lastTouchedButton.dataset) {
                        playMusicNote(lastTouchedButton);
                        lastTouchedButton.classList.add('bounce');
                    }
                    break;
                case 'move':
                    const position = data.toIndex > data.fromIndex ? 'beforebegin' : 'afterend';
                    if (data.toIndex !== -1) {
                        data.parent.children[data.toIndex].insertAdjacentElement(position, data.elem);
                    } else {
                        data.parent.appendChild(data.elem);
                    }
                    if (is('musical-score')) {
                        blockManager.blocksDataUpdate();
                        blockManager.calcPoly();
                        blockManager.saveBlocksData();
                        blockManager.exportMml(mml);
                    }
                    break;
                case 'valueChange':
                    for (const [name, value] of Object.entries(data.afterChange)) {
                        data.target.dataset[name] = value;
                    }
                    if ('tone' in data.target.dataset) {
                        playMusicNote(data.target);
                    }
                    blockManager.blocksDataUpdate();
                    blockManager.saveBlocksData();
                    blockManager.exportMml(mml);
                    break;
                case 'remove':
                    const buttonClassName = data.removedElem.className;
                    data.removedElem.remove();
                    if (is('tones')) {
                        musicalScore.querySelectorAll(`[class*="${buttonClassName}"]`).forEach(elem => {
                            elem.parentElement.remove();
                        });
                    }
                    blockManager.blocksDataUpdate();
                    blockManager.calcPoly();
                    blockManager.saveBlocksData();
                    blockManager.exportMml(mml);
                    break;
                case 'clear':
                    tones.querySelector('ul').textContent = '';
                    musicalScore.querySelectorAll('.track').forEach((track, notFirst) => {
                        if (notFirst) {
                            track.remove();
                        } else {
                            track.textContent = '';
                            blockManager.activeTrack = track;
                        }
                    });
                    lastTouchedButton = null;
                    blockManager.blocksDataUpdate();
                    blockManager.saveBlocksData();
                    blockManager.exportMml(mml);
                    break;
            }
            break;
    }
};

const getNonExistNoteClassName = () => {
    const noteClassNames = [...tones.getElementsByTagName('button')].map(elem => [...elem.classList].find(name => name.includes('note-')));
    for (let index = 1; ; index++) {
        if (!noteClassNames.includes('note-' + index)) {
            return 'note-' + index;
        }
    }
};

document.addEventListener('keydown', e => {
    const ctrlKey = e.ctrlKey || ctrlSw.checked;
    switch (e.key?.toLowerCase()) {
        case ' ':
            if (document.activeElement.tagName.toLowerCase() !== 'input') { // contentEditableのことは考えていない
                e.preventDefault();
                playBtn.click();
            }
            break;
        case 's':
            if (ctrlKey) {
                e.preventDefault();
                !saveBtn.disabled && saveBtn.click();
            }
            break;
        case 'o':
            if (ctrlKey) {
                e.preventDefault();
                !openBtn.disabled && openBtn.click();
            }
            break;
        case 'z':
            ctrlKey && history.undo();
            break;
        case 'y':
            ctrlKey && history.redo();
            break;
    }
});

const actionPromptSwitcher = async item => {
    const { dataset } = item;
    const promptDefinitions = {
        tempo: mmlText => ({
            'tempo': mmlText.replace('t', '')
        }),
        noteValue: mmlText => ({
            'note-value': (mmlText.match(/[0-9]+/) || [''])[0],
            'dot': (mmlText.match(/\.+/) || [''])[0].length
        }),
        rest: mmlText => ({
            'rest': (mmlText.match(/[0-9]+/) || [''])[0],
            'dot': (mmlText.match(/\.+/) || [''])[0].length
        }),
        octave: mmlText => ({
            'octave': mmlText.startsWith('o') ? mmlText.replace('o', '') : (mmlText.match(/[><]+/) || [''])[0].length
        }),
        velocity: mmlText => ({
            'velocity': mmlText.startsWith('@v') ? mmlText.replace('@v', '') : Number((mmlText.match(/[0-9]+/) || [''])[0]) * (mmlText.startsWith('(') ? 1 : -1)
        }),
        noteShift: mmlText => ({
            'note-shift': (mmlText.match(/[0-9]+/) || [''])[0]
        }),
        detune: mmlText => ({
            'detune': mmlText.replace('@d', '')
        }),
        tieSlur: mmlText => ({
            'tie-slur': (mmlText.match(/[0-9]+/) || [''])[0],
            'dot': (mmlText.match(/\.+/) || [''])[0].length
        }),
        repeatStartEnd: mmlText => ({
            'repeat': mmlText.replace('/:', '')
        }),
        macroDef: mmlText => ({
            'macro-def-name': (mmlText.match(/\$([^\{\=]*)[\{\=]/) || [,''])[1],
            'macro-def-arg': (mmlText.match(/\{([^\}]*)\}/) || [,''])[1],
        }),
        macroArgUse: mmlText => ({
            'macro-arg-use': mmlText.replace('%', '')
        }),
        macroUse: mmlText => ({
            'macro-use-name': (mmlText.match(/\$([^\{]*)\{?/) || [,''])[1],
            'macro-use-arg': (mmlText.match(/\{([^\}]*)\}/) || [,''])[1],
        }),
        metaData: mmlText => ({
            'run': () => {
                const metaDataRaw = mmlText;
                const metaDataSplit = metaDataRaw.split(' ');
                const typeDefs = [
                    '#TITLE',
                    '#ARTIST',
                    '#COMMENT',
                    '#CODING',
                    '#PRAGMA',
                    '#OCTAVE',
                    '#VELOCITY',
                    '#WAV9',
                    '#WAV10',
                    '#WAV13',
                    '#OPM',
                    '#OPN',
                    '#FMGAIN',
                    '#USING',
                ];
                let selectIndex = typeDefs.findIndex(def => metaDataSplit[0].startsWith(def));
                selectIndex === -1 && (selectIndex = 0);
                dialogForm.elements['select-meta-data'].selectedIndex = selectIndex;
                const getLabelTextNode = name => dialogForm.elements[name].previousSibling;
                const getOption = () => dialogForm.elements['select-meta-data'].selectedOptions[0];
                const setForm = (numberMode, textMode) => { // [labelText, inputValue, isDisplayNone]
                    getLabelTextNode('number').nodeValue = numberMode[0];
                    dialogForm.elements['number'].value = numberMode[1];
                    dialogForm.elements['number'].parentElement.style.display = numberMode[2] ? 'none' : '';
                    getLabelTextNode('text').nodeValue = textMode[0];
                    dialogForm.elements['text'].value = textMode[1];
                    dialogForm.elements['text'].parentElement.style.display = textMode[2] ? 'none' : '';
                };
                const selectHandler = index => {
                    const isMetaDataType = index === selectIndex;
                    const type = typeDefs[index];
                    switch (type) {
                        case '#TITLE':
                        case '#ARTIST':
                        case '#COMMENT':
                        case '#CODING':
                        case '#PRAGMA':
                            const text = isMetaDataType ? metaDataSplit.slice(1).join(' ') ?? '' : '';
                            setForm(
                                ['無効', '', true],
                                [getOption().label, text, false]
                            );
                            break;

                        case '#OCTAVE':
                        case '#VELOCITY':
                            setForm(
                                ['無効', '', true],
                                ['無効', '', true]
                            );
                            break;

                        case '#WAV9':
                        case '#WAV10':
                        case '#WAV13':
                            const isWav9 = type === '#WAV9';
                            const waveParams = isMetaDataType ? metaDataSplit.slice(1).join(' ')?.split(',') ?? [] : [];
                            setForm(
                                ['波形番号', waveParams[0] ?? 0, false],
                                isWav9 ? ['初期変位,ループフラグ,データ', `${waveParams[1] ?? 0},${waveParams[2] ?? 0},${waveParams[3] ?? ''}`, false]
                                        : ['データ', waveParams[1] ?? '', false]
                            );
                            dialogForm.elements['number'].min = 0;
                            dialogForm.elements['number'].max = isWav9 ? 15 : 31;
                            break;

                        case '#OPM':
                        case '#OPN':
                            setForm(
                                ['音色番号', isMetaDataType ? metaDataSplit[0]?.split('@')[1] ?? 0 : 0, false],
                                ['データ', isMetaDataType ? metaDataSplit.slice(1).join(' ')?.slice(1, -1) ?? '' : '', false]
                            );
                            dialogForm.elements['number'].min = 0;
                            dialogForm.elements['number'].max = 127;

                            break;
                        case '#FMGAIN':
                            setForm(
                                ['音量利得', isMetaDataType ? metaDataSplit[1].replace('\n', '') ?? 91 : 91, false],
                                ['無効', '', true]
                            );
                            dialogForm.elements['number'].min = -127;
                            dialogForm.elements['number'].max = 127;

                            break;
                        case '#USING':
                            setForm(
                                ['和音重ね数', isMetaDataType ? metaDataSplit[2].replace('\n', '') ?? 2 : 2, false],
                                ['無効', '', true]
                            );
                            dialogForm.elements['number'].min = 1;
                            dialogForm.elements['number'].max = '';
                            break;
                    }
                };
                selectHandler(selectIndex);
                dialogForm.elements['select-meta-data'].addEventListener('change', e => {
                    selectHandler(e.target.selectedIndex);
                });
            }
        }),
        otherAction: mmlText => ({
            'other-action': mmlText
        }),
        remove: () => ({})
    };
    for (const type of Object.keys(dataset)) {
        const initValsGenerator = promptDefinitions[type];

        if (initValsGenerator) {
            let mmlText = dataset[type];
            switch (type) {
                case 'repeatStartEnd':
                    if (mmlText === ':/') {
                        const findRepeatStartElem = () => {
                            let findTemp = item.parentElement;
                            while (findTemp && !(findTemp.firstElementChild.dataset.repeatStartEnd?.startsWith('/:'))) {
                                findTemp = findTemp.previousElementSibling;
                            };
                            return findTemp?.firstElementChild || null;
                        };
                        const repeatStart = findRepeatStartElem();
                        if (!repeatStart) {
                            const ul = blockManager.activeTrack;
                            const li = document.createElement('li');
                            const baseItem = action.querySelector('.repeat-start-end');
                            const newItem = baseItem.cloneNode(true);
                            li.appendChild(newItem);
                            ul.insertBefore(li, item.parentElement);
                            item = newItem;
                        } else {
                            item = repeatStart;
                        }
                        mmlText = item.dataset.repeatStartEnd;
                    }
                    break;
                case 'macroDef':
                    if (mmlText === ';') {
                        return;
                    }
                    break;
            }
            const initVals = initValsGenerator(mmlText);
            await dialogFormManager.prompt(type, initVals, item);
            break;
        }
    }
};
let lastTouchedButton = tones.querySelector('button');
editor.addEventListener('click', async e => {
    const ctrlKey = e.ctrlKey || ctrlSw.checked;
    const is = id => Boolean(e.target.closest('#' + id));
    const isButton =  e.target.tagName.toLowerCase() === 'button';
    if ([tones, action, musicalScore].some(target => target.classList.contains('no-op'))) {
        return;
    } else if (is('tones')) {
        if (isButton) {
            lastTouchedButton = e.target;
            await dialogFormManager.prompt('tone', {
                'tone-name': e.target.ariaLabel,
                'tone-def': e.target.dataset.tone,
                'run': () => {
                    const toneName = dialogForm.elements['tone-name'];
                    toneName.insertAdjacentElement('afterend', picker);
                    const pickerElem = document.querySelector('emoji-picker');
                    toneName.addEventListener('focus', () => {
                        pickerElem.classList.add('expaned');
                    }, {once: true});
                    pickerElem.addEventListener('emoji-click', e => toneName.value = e.detail.unicode);
                }
            }, e.target);
            flmml.play(e.target.dataset.tone + e.target.dataset.tonePitch);
            blockManager.blocksDataUpdate();
            blockManager.saveBlocksData();
            blockManager.exportMml(mml);
        } else {
            const ul = tones.querySelector('ul');
            const li = document.createElement('li');
            const nonExistClassName = getNonExistNoteClassName();
            const toneButton = `<button class="material-icons note ${nonExistClassName}" aria-label="無調整" draggable="true" data-tone="" data-tone-pitch="c">music_note</button>`;
            li.innerHTML = toneButton;
            const newItem = li.firstElementChild;
            ul.appendChild(li);
            lastTouchedButton = newItem;
            flmml.play(newItem.dataset.tone + newItem.dataset.tonePitch);
            history.pushState({
                operation: 'copy',
                toIndex: -1,
                newElem: li,
                parent: ul
            });
        }
    } else if (is('action')) {
        if (isButton) {
            if ('otherAction' in e.target.dataset) {
                await actionPromptSwitcher(e.target);
            }
            const ul = blockManager.activeTrack;
            const li = document.createElement('li');
            const newItem = e.target.cloneNode(true);
            if ('metaData' in newItem.dataset || 'macroDef' in newItem.dataset
                || 'macroArgUse' in newItem.dataset || 'macroUse' in newItem.dataset) {
                await actionPromptSwitcher(newItem);
            }
            if ('tieSlur' in newItem.dataset) {
                newItem.ariaLabel = 'スラー';
            } else if ('repeatStartEnd' in newItem.dataset) {
                newItem.classList.remove('material-icons');
                newItem.ariaLabel = 'リピート開始';
                newItem.textContent = '◆';
                newItem.dataset.repeatStartEnd = '/:';
            } else if ('polyStartEnd' in newItem.dataset) {
                newItem.dataset.polyStartEnd = '[';
                newItem.textContent = '[';
            } else if ('macroDef' in newItem.dataset) {
                newItem.textContent = '$=';
            }
            li.appendChild(newItem);
            ul.appendChild(li);
            lastTouchedButton = newItem;
            blockManager.blocksDataUpdate();
            blockManager.calcPoly();
            blockManager.saveBlocksData();
            blockManager.exportMml(mml);
            history.pushState({
                operation: 'copy',
                toIndex: -1,
                newElem: li,
                parent: ul
            });
            if ('repeatStartEnd' in lastTouchedButton.dataset || 'polyStartEnd' in lastTouchedButton.dataset
                || 'macroDef' in lastTouchedButton.dataset) {
                const li = document.createElement('li')
                const newItem = e.target.cloneNode(true);
                if ('repeatStartEnd' in lastTouchedButton.dataset) {
                    newItem.ariaLabel = 'リピート終了';
                    newItem.dataset.repeatStartEnd = ':/';
                } else if ('polyStartEnd' in lastTouchedButton.dataset) {
                    newItem.dataset.polyStartEnd = ']';
                    newItem.textContent = ']';
                } else if ('macroDef' in lastTouchedButton.dataset) {
                    newItem.dataset.macroDef = ';';
                    newItem.textContent = ';';
                }
                li.appendChild(newItem);
                lastTouchedButton.parentElement.insertAdjacentElement('afterend', li);
                blockManager.blocksDataUpdate();
                blockManager.saveBlocksData();
                blockManager.exportMml(mml);
                history.pushState({
                    operation: 'copy',
                    toIndex: -1,
                    newElem: li,
                    parent: ul
                });
            }
        }
    } else if (is('musical-score')) {
        if (isButton && e.target !== addTrackBtn && e.target !== removeTrackBtn) {
            e.target.closest('.track') && (blockManager.activeTrack = e.target.closest('.track'));
            if ('tone' in e.target.dataset) {
                playMusicNote(e.target);
                resetAnimation(e.target, 'bounce');
                if (ctrlKey) {
                    await dialogFormManager.prompt('tonePitch', {
                        'tone-pitch': (e.target.dataset.tonePitch.match(/[0-9]+/) || [''])[0],
                        'dot': (e.target.dataset.tonePitch.match(/\.+/) || [''])[0].length
                    }, e.target);
                    playMusicNote(e.target);
                }
            } else {
                await actionPromptSwitcher(e.target);
            }
            lastTouchedButton = e.target;
            blockManager.blocksDataUpdate();
            blockManager.saveBlocksData();
            blockManager.exportMml(mml);
        } else {
            if (lastTouchedButton) {
                e.target.closest('.track') && (blockManager.activeTrack = e.target.closest('.track'));
                const ul = blockManager.activeTrack;
                const li = document.createElement('li');
                const newItem = lastTouchedButton.cloneNode(true);
                if ('repeatStartEnd' in newItem.dataset) {
                    newItem.classList.remove('material-icons');
                    newItem.ariaLabel = 'リピート開始';
                    newItem.textContent = '◆';
                    newItem.dataset.repeatStartEnd = '/:' + (newItem.dataset.repeatStartEnd.match(/[0-9]+/) || [''])[0];
                }
                li.appendChild(newItem);
                ul.appendChild(li);
                lastTouchedButton = newItem;
                blockManager.blocksDataUpdate();
                blockManager.calcPoly();
                blockManager.saveBlocksData();
                blockManager.exportMml(mml);
                history.pushState({
                    operation: 'copy',
                    toIndex: -1,
                    newElem: li,
                    parent: ul
                });
                if ('tonePitch' in newItem.dataset) {
                    newItem.dataset.tonePitch = newItem.dataset.tonePitch.replace(/[><]+/, '');
                    playMusicNote(newItem);
                    newItem.classList.add('bounce');
                } else if ('repeatStartEnd' in lastTouchedButton.dataset) {
                    const li = document.createElement('li')
                    const newItem = lastTouchedButton.cloneNode(true);
                    newItem.classList.add('material-icons');
                    newItem.ariaLabel = 'リピート終了';
                    newItem.textContent = 'repeat';
                    newItem.dataset.repeatStartEnd = ':/';
                    li.appendChild(newItem);
                    lastTouchedButton.parentElement.insertAdjacentElement('afterend', li);
                    blockManager.blocksDataUpdate();
                    blockManager.saveBlocksData();
                    blockManager.exportMml(mml);
                    history.pushState({
                        operation: 'copy',
                        toIndex: -1,
                        newElem: li,
                        parent: ul
                    });
                }
            }
        }
    }
});

editor.addEventListener('contextmenu', e => {
    const parent = target => target.closest('#tones, #musical-score');
    const is = id => Boolean(e.target.closest('#' + id));
    const isButton =  e.target.tagName.toLowerCase() === 'button';
    if (parent(e.target)?.classList.contains('no-op')) {
        return;
    } else if (parent(e.target)) {
        const target = isButton && e.target !== addTrackBtn && e.target !== removeTrackBtn
                        ? e.target : lastTouchedButton;
        if (!target || parent(target) !== parent(e.target)) {
            return;
        }
        e.preventDefault();
        blockManager.activeTrack = target.closest('.track') || blockManager.activeTrack;
        const removeTarget = target.parentElement;
        const buttonClassName = target.className;
        const ul = target.closest('#tones')?.querySelector('ul') || blockManager.activeTrack;
        const removeTargetIndex = [...ul.children].indexOf(removeTarget);
        lastTouchedButton = removeTarget.previousElementSibling?.firstElementChild
                            || removeTarget.nextElementSibling?.firstElementChild
                            || null;
        history.pushState({
            operation: 'remove',
            removedElem: removeTarget,
            removedIndex: removeTargetIndex,
            parent: ul
        });
        if (is('tones')) {
            musicalScore.querySelectorAll(`[class*="${buttonClassName}"]`).forEach(elem => {
                elem.parentElement.remove();
            });
        } else if ('macroDef' in target.dataset) {
            musicalScore.querySelectorAll(`[data-macro-use="${target.dataset.macroDef.replace('=', '')}"]`).forEach(elem => {
                elem.parentElement.remove();
            });
        }
        removeTarget.remove();
        blockManager.blocksDataUpdate();
        blockManager.calcPoly();
        blockManager.saveBlocksData();
        blockManager.exportMml(mml);
    }
});

let lastY = null, ignoneTouch = false, dragJudgementTimer = null;
editor.addEventListener('touchstart', e => {
    const touchY = [...e.touches].at(-1).pageY;
    lastY = touchY;
    dragJudgementTimer = setTimeout(() => {
        ignoneTouch = true;
    }, 500);
});
const wheelHandler = e => {
    const ctrlKey = e.ctrlKey || ctrlSw.checked;
    const is = id => Boolean(e.target.closest('#' + id));
    const isButton =  e.target.tagName.toLowerCase() === 'button';
    if (e.type === 'touchmove') {
        const touchY = [...e.touches].at(-1).pageY;
        if (ignoneTouch) {
            e.cancelable && e.preventDefault();
            return;
        } else if (touchY - lastY < -20) {
            e.deltaY = -1;
            clearTimeout(dragJudgementTimer);
        } else if (touchY - lastY > 20) {
            e.deltaY = 1;
            clearTimeout(dragJudgementTimer);
        } else {
            e.cancelable && e.preventDefault();
            return;
        }
        lastY = touchY;
        ignoneTouch = true;
        setTimeout(() => ignoneTouch = false, 50);

    }
    const isPositive = e.deltaY < 0;
    let target = isButton ? e.target : lastTouchedButton?.closest('#musical-score') && lastTouchedButton;
    if (!target) {
        return;
    } else if (is('musical-score')) {
        if (musicalScore.classList.contains('no-op')) {
            return;
        }
        e.preventDefault();
        let beforeChange = JSON.parse(JSON.stringify(target.dataset));
        if (!ctrlKey && 'tone' in target.dataset) {
            const pitches = ['c','c+','d','d+','e','f','f+','g','g+','a','a+','b'];
            const octave = ['>', '<'];
            const currentPitch = target.dataset.tonePitch;
            const currentPitchIndex = pitches.findIndex(pitch => currentPitch.match(/[a-g]\+?/)[0] === pitch);
            const countStr = (target, str) => (target.match(new RegExp(str, 'g')) || []).length;
            const octaveCount = [
                countStr(currentPitch, octave[0]),
                countStr(currentPitch, octave[1])
            ];
            const octaveStr = octave[0].repeat(octaveCount[0]) + octave[1].repeat(octaveCount[1]);
            const noteValue = (currentPitch.match(/[0-9]+/) || [''])[0];
            const dots = '.'.repeat((target.dataset.tonePitch.match(/\.+/) || [''])[0].length);
            if (isPositive) { // Up
                if (currentPitchIndex === pitches.length - 1) {
                    if (octaveCount[0]) {
                        target.dataset.tonePitch = octaveStr.substring(1) + pitches.at(0) + noteValue + dots;
                    } else {
                        target.dataset.tonePitch = octaveStr + octave[1] + pitches.at(0) + noteValue + dots;
                    }
                } else {
                    target.dataset.tonePitch = octaveStr + pitches[currentPitchIndex + 1] + noteValue + dots;
                }
            } else { // Down
                if (currentPitchIndex === 0) {
                    if (octaveCount[1]) {
                        target.dataset.tonePitch = octaveStr.substring(1) + pitches.at(-1) + noteValue + dots;
                    } else {
                        target.dataset.tonePitch = octaveStr + octave[0] + pitches.at(-1) + noteValue + dots;
                    }
                } else {
                    target.dataset.tonePitch = octaveStr + pitches[currentPitchIndex - 1] + noteValue + dots;
                }
            }
            playMusicNote(target);
        } else {
            const increaseBase = isPositive ? 1 : -1;
            const minmax = (current, min = -Infinity, max = Infinity) => current + increaseBase < min ? 0 : current + increaseBase > max ? 0 : increaseBase;
            if (ctrlKey && 'tonePitch' in target.dataset) {
                const noteValue = Number((target.dataset.tonePitch.match(/[0-9]+/) || [''])[0]);
                const dots = '.'.repeat((target.dataset.tonePitch.match(/\.+/) || [''])[0].length);
                const increase = minmax(noteValue, 0, 384);
                const newNoteValue = noteValue + increase !== 0 ? noteValue + increase : '';
                target.dataset.tonePitch = target.dataset.tonePitch.replace(/[0-9]*\.*/g, '') + newNoteValue + dots;
                playMusicNote(target);
            } else if ('tempo' in target.dataset) {
                const tempo = Number(target.dataset.tempo.replace('t', ''));
                const increase = minmax(tempo, 0);
                target.dataset.tempo = 't' + (tempo + increase * 10);
            } else if ('noteValue' in target.dataset) {
                const noteValue = Number((target.dataset.noteValue.match(/[0-9]+/) || [''])[0]);
                const increase = minmax(noteValue, 1, 384);
                target.dataset.noteValue = target.dataset.noteValue.replace(/[0-9]+/, noteValue + increase);
            } else if ('rest' in target.dataset) {
                const rest = Number((target.dataset.rest.match(/[0-9]+/) || [''])[0]);
                const dots = '.'.repeat((target.dataset.rest.match(/\.+/) || [''])[0].length);
                const increase = minmax(rest, 0, 384);
                const newRest = rest + increase !== 0 ? rest + increase : '';
                target.dataset.rest = 'r' + newRest + dots;
            } else if ('octave' in target.dataset) {
                const isAbsolute = target.dataset.octave.startsWith('o');
                if (isAbsolute) {
                    const octave = Number(target.dataset.octave.replace('o', ''));
                    const increase = minmax(octave, 0, 8);
                    target.dataset.octave = 'o' + (octave + increase);
                } else {
                    const octave = (target.dataset.octave.match(/<+/) || [''])[0].length - (target.dataset.octave.match(/>+/) || [''])[0].length;
                    const increase = minmax(octave, -8, 8);
                    target.dataset.octave = octave + increase > 0 ? '<'.repeat(octave + increase) : '>'.repeat(-(octave + increase));
                }
            } else if ('velocity' in target.dataset) {
                const isAbsolute = target.dataset.velocity.startsWith('@v');
                if (isAbsolute) {
                    const velocity = Number(target.dataset.velocity.replace('@v', ''));
                    const increase = minmax(velocity, 0, 127);
                    target.dataset.velocity = '@v' + (velocity + increase);
                } else {
                    const velocity = Number((target.dataset.velocity.match(/[0-9]+/) || [''])[0]) * (target.dataset.velocity.startsWith('(') ? 1 : -1);
                    const increase = minmax(velocity, -127, 127);
                    target.dataset.velocity = (velocity + increase >= 0 ? '(' : ')') + Math.abs(velocity + increase);
                }
            } else if ('noteShift' in target.dataset) {
                const noteShift = Number((target.dataset.noteShift.match(/-?[0-9]+/) || [''])[0]);
                const increase = increaseBase;
                target.dataset.noteShift = target.dataset.noteShift.match(/@?ns/)[0] + (noteShift + increase);
            } else if ('detune' in target.dataset) {
                const detune = Number(target.dataset.detune.replace('@d', ''));
                const increase = increaseBase;
                target.dataset.detune = '@d' + (detune + increase);
            } else if ('tieSlur' in target.dataset) {
                const tieSlur = Number((target.dataset.tieSlur.match(/[0-9]+/) || [''])[0]);
                const dots = '.'.repeat((target.dataset.tieSlur.match(/\.+/) || [''])[0].length);
                const increase = minmax(tieSlur, 0, 384);
                const newTieSlur = tieSlur + increase !== 0 ? tieSlur + increase : '';
                target.dataset.tieSlur = '&' + newTieSlur + dots;
                if (target.dataset.tieSlur === '&') {
                    target.ariaLabel = 'スラー';
                } else {
                    target.ariaLabel = 'タイ';
                }
            } else if ('repeatStartEnd' in target.dataset) {
                if (target.dataset.repeatStartEnd === ':/') {
                    const findRepeatStartElem = () => {
                        let findTemp = target.parentElement;
                        while (findTemp && !(findTemp.firstElementChild.dataset.repeatStartEnd?.startsWith('/:'))) {
                            findTemp = findTemp.previousElementSibling;
                        };
                        return findTemp?.firstElementChild || null;
                    };
                    const repeatStart = findRepeatStartElem();
                    if (!repeatStart) {
                        const ul = blockManager.activeTrack;
                        const li = document.createElement('li');
                        const baseItem = action.querySelector('.repeat-start-end');
                        const newItem = baseItem.cloneNode(true);
                        li.appendChild(newItem);
                        ul.insertBefore(li, target.parentElement);
                        target = newItem;
                    } else {
                        target = repeatStart;
                    }
                    beforeChange = JSON.parse(JSON.stringify(target.dataset));
                }
                const repeat = Number((target.dataset.repeatStartEnd.match(/[0-9]+/) || [-1])[0]);
                const increase = minmax(repeat, -1);
                const newRepeat = repeat + increase !== -1 ? repeat + increase : '';
                target.dataset.repeatStartEnd = '/:' + newRepeat;
            }
        }
        const afterChange = JSON.parse(JSON.stringify(target.dataset));
        if (JSON.stringify(beforeChange) !== JSON.stringify(afterChange)) {
            history.pushState({
                operation: 'valueChange',
                target,
                beforeChange,
                afterChange
            });
        }
        lastTouchedButton = target;
        blockManager.blocksDataUpdate();
        blockManager.saveBlocksData();
        blockManager.exportMml(mml);
    }
};
editor.addEventListener('wheel', wheelHandler);
editor.addEventListener('touchmove', wheelHandler);
editor.addEventListener('touchend', () => {
    ignoneTouch = false;
});

let dragInfo = {};
editor.addEventListener('dragstart', e => {
    const editorSectionElem = e.target.nodeType === 1/* ELEMENT */ && e.target.closest('#tones, #action, #musical-score');
    dragInfo = {
        from: editorSectionElem,
        item: e.target
    };
    e.dataTransfer.effectAllowed = 'copyMove';
});
let dropEffect = null;
[tones, action, musicalScore].forEach(target => {
    const dragEventHandler = e => {
        const ctrlKey = e.ctrlKey || ctrlSw.checked;
        const {from = null} = dragInfo;
        const dt = e.dataTransfer;
        switch (from) {
            case tones:
                switch (target) {
                    case tones:
                        e.preventDefault();
                        if (!ctrlKey) {
                            dt.dropEffect = 'move';
                        } else {
                            dt.dropEffect = 'copy';
                        }
                        break;
                    case action:
                        break;
                    case musicalScore:
                        e.preventDefault();
                        dt.dropEffect = 'copy';
                        break;
                }
                break;
            case action:
                switch (target) {
                    case tones:
                        break;
                    case action:
                        break;
                    case musicalScore:
                        e.preventDefault();
                        dt.dropEffect = 'copy';
                        break;
                }
                break;
            case musicalScore:
                switch (target) {
                    case tones:
                        break;
                    case action:
                        break;
                    case musicalScore:
                        e.preventDefault();
                        if (!ctrlKey) {
                            dt.dropEffect = 'move';
                        } else {
                            dt.dropEffect = 'copy';
                        }
                        break;
                }
                break;
        }
        dropEffect = dt.dropEffect;
    };
    target.addEventListener('dragover', dragEventHandler);
    const dragenterEventHandler = e => {
        const {from = null} = dragInfo;
        const isButton =  e.target.tagName.toLowerCase() === 'button';
        const addClass = () => e.target.classList.add('droppable');
        switch (from) {
            case tones:
                switch (target) {
                    case tones:
                        e.preventDefault(); // polyfill用
                        if (isButton) {
                            addClass();
                        }
                        break;
                    case action:
                        break;
                    case musicalScore:
                        e.preventDefault(); // polyfill用
                        if (isButton) {
                            addClass();
                        }
                        break;
                }
                break;
            case action:
                switch (target) {
                    case tones:
                        break;
                    case action:
                        break;
                    case musicalScore:
                        e.preventDefault(); // polyfill用
                        if (isButton) {
                            addClass();
                        }
                        break;
                }
                break;
            case musicalScore:
                switch (target) {
                    case tones:
                        break;
                    case action:
                        break;
                    case musicalScore:
                        e.preventDefault(); // polyfill用
                        if (isButton) {
                            addClass();
                        }
                        break;
                }
                break;
        }
    };
    target.addEventListener('dragenter', dragenterEventHandler);
    const dragleaveEventHandler = e => {
        const {from = null} = dragInfo;
        const isButton =  e.target.tagName.toLowerCase() === 'button';
        const removeClass = () => e.target.classList.remove('droppable');
        switch (from) {
            case tones:
                switch (target) {
                    case tones:
                        if (isButton) {
                            removeClass();
                        }
                        break;
                    case action:
                        break;
                    case musicalScore:
                        if (isButton) {
                            removeClass();
                        }
                        break;
                }
                break;
            case action:
                switch (target) {
                    case tones:
                        break;
                    case action:
                        break;
                    case musicalScore:
                        if (isButton) {
                            removeClass();
                        }
                        break;
                }
                break;
            case musicalScore:
                switch (target) {
                    case tones:
                        break;
                    case action:
                        break;
                    case musicalScore:
                        if (isButton) {
                            removeClass();
                        }
                        break;
                }
                break;
        }
    };
    target.addEventListener('dragleave', dragleaveEventHandler);
    target.addEventListener('drop', async e => {
        e.preventDefault();
        if (e.dataTransfer.items?.length) { // ?はpolyfill用
            return;
        }
        e.dataTransfer.dropEffect = e.dataTransfer.dropEffect !== 'none' ? e.dataTransfer.dropEffect : dropEffect;
        const {from, item} = dragInfo;
        const ul = e.target.closest('#tones')?.querySelector('ul') || e.target.closest('.track') || blockManager.activeTrack;
        const itemIndex = [...ul.children].indexOf(item.parentElement);
        const targetIndex = [...ul.children].indexOf(e.target.parentElement);
        const targetIsButton =  e.target.tagName.toLowerCase() === 'button';
        let newNode;
        switch (e.dataTransfer.dropEffect) {
            case 'copy':
                const li = document.createElement('li')
                const newItem = item.cloneNode(true);
                if (target === tones) {
                    const noteClassName = [...item.classList].find(name => name.includes('note-'));
                    newItem.classList.replace(noteClassName, getNonExistNoteClassName());
                } else if (from === action) {
                    if ('tieSlur' in newItem.dataset) {
                        newItem.ariaLabel = 'スラー';
                    } else if ('metaData' in newItem.dataset || 'macroDef' in newItem.dataset
                        || 'macroArgUse' in newItem.dataset || 'macroUse' in newItem.dataset
                        || 'otherAction' in newItem.dataset) {
                        await actionPromptSwitcher(newItem);
                    }
                }
                if ('repeatStartEnd' in newItem.dataset) {
                    newItem.classList.remove('material-icons');
                    newItem.ariaLabel = 'リピート開始';
                    newItem.textContent = '◆';
                    newItem.dataset.repeatStartEnd = '/:' + (newItem.dataset.repeatStartEnd.match(/[0-9]+/) || [''])[0];
                } else if ('polyStartEnd' in newItem.dataset) {
                    newItem.dataset.polyStartEnd = '[';
                    newItem.textContent = '[';
                } else if ('macroDef' in newItem.dataset) {
                    newItem.dataset.macroDef === ';' && (newItem.dataset.macroDef = '$=');
                    newItem.textContent = '$=';
                }
                li.appendChild(newItem);
                newNode = li;
                break;
            case 'move':
                newNode = item.parentElement;
                break;
        }
        if (targetIsButton && e.target.id !== 'add-track' && e.target.id !== 'remove-track') {
            const position = e.dataTransfer.dropEffect === 'copy' || targetIndex < itemIndex ? 'beforebegin' : 'afterend';
            e.target.parentElement.insertAdjacentElement(position, newNode);
        } else {
            ul.appendChild(newNode);
        }
        lastTouchedButton = newNode.firstElementChild;
        if (target === musicalScore) {
            blockManager.activeTrack = ul;
            blockManager.blocksDataUpdate();
            e.dataTransfer.dropEffect === 'move' && blockManager.calcPoly();
            blockManager.saveBlocksData();
            blockManager.exportMml(mml);
            if ('tonePitch' in lastTouchedButton.dataset) {
                lastTouchedButton.dataset.tonePitch = lastTouchedButton.dataset.tonePitch.replace(/[><]+/, '');
                playMusicNote(lastTouchedButton);
                lastTouchedButton.classList.add('bounce');
            }
        }
        switch (e.dataTransfer.dropEffect) {
            case 'copy':
                history.pushState({
                    operation: 'copy',
                    toIndex: targetIndex,
                    newElem: newNode,
                    parent: ul
                });
                break;
            case 'move':
                history.pushState({
                    operation: 'move',
                    fromIndex: itemIndex,
                    toIndex: targetIndex,
                    elem: newNode,
                    parent: ul
                });
                break;
        }
        if (e.dataTransfer.dropEffect === 'copy' && ('repeatStartEnd' in lastTouchedButton.dataset
            || 'polyStartEnd' in lastTouchedButton.dataset || 'macroDef' in lastTouchedButton.dataset)) {
            const li = document.createElement('li')
            const newItem = item.cloneNode(true);
            if ('repeatStartEnd' in lastTouchedButton.dataset) {
                newItem.classList.add('material-icons');
                newItem.ariaLabel = 'リピート終了';
                newItem.textContent = 'repeat';
                newItem.dataset.repeatStartEnd = ':/';
            } else if ('polyStartEnd' in lastTouchedButton.dataset) {
                newItem.dataset.polyStartEnd = ']';
                newItem.textContent = ']';
            } else if ('macroDef' in lastTouchedButton.dataset) {
                newItem.dataset.macroDef = ';';
                newItem.textContent = ';';
            }
            li.appendChild(newItem);
            newNode.insertAdjacentElement('afterend', li);
            blockManager.blocksDataUpdate();
            blockManager.saveBlocksData();
            blockManager.exportMml(mml);
            history.pushState({
                operation: 'copy',
                toIndex: targetIndex + 1,
                newElem: li,
                parent: ul
            });
        }
    });
    const dragendEventHandler = e => {
        [...document.getElementsByClassName('droppable')].forEach(elem => {
            elem.classList.remove('droppable');
        });
    };
    target.addEventListener('dragend', dragendEventHandler);
});

editor.addEventListener('animationend', e => {
    e.target.classList.remove('bounce');
    e.target.classList.remove('pop');
});

addTrackBtn.addEventListener('click', e => {
    e.stopPropagation();
    const newTrack = document.createElement('ul');
    newTrack.classList.add('track');
    blockManager.activeTrack = newTrack;
    musicalScore.insertBefore(newTrack, addTrackBtn);
});

removeTrackBtn.addEventListener('click', e => {
    e.stopPropagation();
    const lastTrack = [...document.getElementsByClassName('track')].at(-1);
    const previousTrackSibling = lastTrack.previousElementSibling
    lastTrack.remove();
    blockManager.activeTrack = previousTrackSibling;
    blockManager.blocksDataUpdate();
    blockManager.saveBlocksData();
    blockManager.exportMml(mml);
});

dialog.addEventListener('pointerdown', e => {
    if (e.target === dialog) {
        dialog.addEventListener('pointerup', e => {
            if (e.target === dialog) {
                dialog.close();
            }
        }, {once: true});
    }
});

dialog.addEventListener('close', () => {
    switch (dialogFormManager.type) {
        case 'tone':
            document.querySelector('emoji-picker').classList.remove('expaned');
            break;
    }
});

playBtn.addEventListener('click', () => {
    const isPlaying = flmml.isPlaying();
    if (!isPlaying) {
        flmml.play(mml.getMml());
        flmml.addEventListener('compilecomplete', playAnimationStart);
        clearBtn.disabled = true;
    } else {
        flmml.stop();
        blockManager.stopRendering();
        flmml.removeEventListener('compilecomplete', playAnimationStart);
        clearBtn.disabled = false;
    }
    playBtn.innerHTML = !isPlaying ? stopHtml : playHtml;
});

clearBtn.addEventListener('click', () => {
    if (confirm('音色と追加したブロックを全て消去しますか？')) {
        const musicalScoreChildren = [...musicalScore.children];
        musicalScoreChildren.pop();
        history.pushState({
            operation: 'clear',
            tonesChildren: [...tones.querySelector('ul').children],
            musicalScoreChildren,
            lastTouchedButton
        });
        tones.querySelector('ul').textContent = '';
        const ul = tones.querySelector('ul');
        const li = document.createElement('li');
        const toneButton = `<button class="material-icons note note-1" aria-label="無調整" draggable="true" data-tone="" data-tone-pitch="c">music_note</button>`;
        li.innerHTML = toneButton;
        const newItem = li.firstElementChild;
        ul.appendChild(li);
        lastTouchedButton = newItem;
        musicalScore.querySelectorAll('.track').forEach((track, notFirst) => {
            if (notFirst) {
                track.remove();
            } else {
                track.textContent = '';
                blockManager.activeTrack = track;
            }
        });
        flmml.play('');
        blockManager.blocksDataUpdate();
        blockManager.saveBlocksData();
        blockManager.exportMml(mml);
    }
});

copyBtn.addEventListener('click', () => {
    const mmlText = mml.getMml();
    const textCache = copyBtn.innerHTML;
    copyBtn.disabled = true;
    navigator.clipboard.writeText(mmlText)
    .then(() => {
        copyBtn.disabled = true;
        copyBtn.innerHTML = createMIsHtml('content_copy') + 'コピーしました';
        setTimeout(() => {
            copyBtn.innerHTML = textCache;
            copyBtn.disabled = false;
        }, 1500);
    })
    .catch(e => alert('コピーできませんでした\n' + e));
});

pasteBtn.addEventListener('click', () => {
    const textCache = pasteBtn.innerHTML;
    pasteBtn.disabled = true;
    navigator.clipboard.readText()
    .then(text => {
        pasteBtn.disabled = true;
        if (text) {
            mml.setMml(text.replace(/\r/g, ''));
            blockManager.importMml(mml);
            pasteBtn.innerHTML = createMIsHtml('content_paste') + '貼り付けました';
        } else {
            pasteBtn.innerHTML = createMIsHtml('content_paste') + '内容がありません';
        }
        setTimeout(() => {
            pasteBtn.innerHTML = textCache;
            pasteBtn.disabled = false;
        }, 1500);
    })
    .catch(e => alert('貼り付けできませんでした\n' + e));
});

saveBtn.addEventListener('click', () => {
    const mmlText = mml.getMml();
    const mmlArr = mml.getMmlArr();
    const fileName = mmlArr.find(mmlTextLine => mmlTextLine.startsWith('#TITLE'))?.split(' ').slice(1).join(' ') ?? '無題';
    const blob = new Blob([mmlText], {type: 'text/plain'});
    const link = document.createElement('a');
    link.download = fileName + '.mml';
    link.href = URL.createObjectURL(blob);
    link.click();
    URL.revokeObjectURL(link.href);
    if (fileName === '無題') {
        alert('ファイル名を付けるには、先頭にメタデータブロックを追加->タイトルを選択して入力->確定してタイトルを付けてください。');
    }
});

openBtn.addEventListener('click', () => {
    const inputFile = document.createElement('input');
    const fr = new FileReader();
    inputFile.type = 'file';
    inputFile.accept = '.mml,.flmml,.txt'
    inputFile.click();
    inputFile.onchange = () => {
        fr.onload = () => {
            mml.setMml(fr.result);
            blockManager.importMml(mml);
        };
        fr.readAsText(inputFile.files[0]);
    }
});

if ('ontouchstart' in window || navigator.maxTouchPoints) {
    document.body.classList.add('mobile');
}

history.onPushstate = obj => {
    undoBtn.disabled = false;
    redoBtn.disabled = true;
};

undoBtn.addEventListener('click', () => {
    const { canUndo, canRedo } = history.undo();
    undoBtn.disabled = !canUndo;
    redoBtn.disabled = !canRedo;
});
redoBtn.addEventListener('click', () => {
    const { canUndo, canRedo } = history.redo()
    undoBtn.disabled = !canUndo;
    redoBtn.disabled = !canRedo;
});